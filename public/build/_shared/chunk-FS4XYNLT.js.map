{
  "version": 3,
  "sources": ["../../../node_modules/@babel/runtime/helpers/esm/extends.js", "../../../node_modules/history/index.js", "../../../../packages/react-router/index.tsx", "../../../../packages/react-router-dom/index.tsx", "../../../node_modules/cookie/index.js", "../../../node_modules/@remix-run/server-runtime/esm/cookies.js", "../../../node_modules/@remix-run/server-runtime/esm/responses.js", "../../../node_modules/@remix-run/server-runtime/esm/data.js", "../../../node_modules/@remix-run/server-runtime/esm/entry.js", "../../../node_modules/@remix-run/server-runtime/esm/errors.js", "../../../node_modules/set-cookie-parser/lib/set-cookie.js", "../../../node_modules/@remix-run/server-runtime/esm/headers.js", "../../../node_modules/@remix-run/server-runtime/esm/mode.js", "../../../node_modules/@remix-run/server-runtime/esm/routeMatching.js", "../../../node_modules/@remix-run/server-runtime/esm/routes.js", "../../../node_modules/@remix-run/server-runtime/node_modules/jsesc/jsesc.js", "../../../node_modules/@remix-run/server-runtime/esm/serverHandoff.js", "../../../node_modules/@remix-run/server-runtime/esm/server.js", "../../../node_modules/@remix-run/server-runtime/esm/warnings.js", "../../../node_modules/@remix-run/server-runtime/esm/sessions.js", "../../../node_modules/@remix-run/server-runtime/esm/sessions/cookieStorage.js", "../../../node_modules/@remix-run/server-runtime/esm/sessions/memoryStorage.js", "../../../node_modules/@remix-run/server-runtime/esm/index.js", "../../../node_modules/@remix-run/cloudflare/crypto.js", "../../../node_modules/@remix-run/cloudflare/implementations.js", "../../../node_modules/@remix-run/cloudflare/sessions/cloudflareKVSessionStorage.js", "../../../node_modules/@remix-run/cloudflare/index.js", "../../../node_modules/@remix-run/react/esm/browser.js", "../../../node_modules/@remix-run/react/esm/components.js", "../../../node_modules/@remix-run/react/esm/_virtual/_rollupPluginBabelHelpers.js", "../../../node_modules/@remix-run/react/esm/errorBoundaries.js", "../../../node_modules/@remix-run/react/esm/invariant.js", "../../../node_modules/@remix-run/react/esm/links.js", "../../../node_modules/@remix-run/react/esm/routeModules.js", "../../../node_modules/@remix-run/react/esm/markup.js", "../../../node_modules/@remix-run/react/esm/routes.js", "../../../node_modules/@remix-run/react/esm/data.js", "../../../node_modules/@remix-run/react/esm/transition.js", "../../../node_modules/@remix-run/react/esm/routeMatching.js", "../../../node_modules/@remix-run/react/esm/index.js", "../../../node_modules/@remix-run/react/esm/scroll-restoration.js", "../../../node_modules/remix/esm/index.js"],
  "sourcesContent": ["export default function _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}", "import _extends from '@babel/runtime/helpers/esm/extends';\n\n/**\r\n * Actions represent the type of change to a location value.\r\n *\r\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#action\r\n */\nvar Action;\n\n(function (Action) {\n  /**\r\n   * A POP indicates a change to an arbitrary index in the history stack, such\r\n   * as a back or forward navigation. It does not describe the direction of the\r\n   * navigation, only that the current index changed.\r\n   *\r\n   * Note: This is the default action for newly created history objects.\r\n   */\n  Action[\"Pop\"] = \"POP\";\n  /**\r\n   * A PUSH indicates a new entry being added to the history stack, such as when\r\n   * a link is clicked and a new page loads. When this happens, all subsequent\r\n   * entries in the stack are lost.\r\n   */\n\n  Action[\"Push\"] = \"PUSH\";\n  /**\r\n   * A REPLACE indicates the entry at the current index in the history stack\r\n   * being replaced by a new one.\r\n   */\n\n  Action[\"Replace\"] = \"REPLACE\";\n})(Action || (Action = {}));\n\nvar readOnly = process.env.NODE_ENV !== \"production\" ? function (obj) {\n  return Object.freeze(obj);\n} : function (obj) {\n  return obj;\n};\n\nfunction warning(cond, message) {\n  if (!cond) {\n    // eslint-disable-next-line no-console\n    if (typeof console !== 'undefined') console.warn(message);\n\n    try {\n      // Welcome to debugging history!\n      //\n      // This error is thrown as a convenience so you can more easily\n      // find the source for a warning that appears in the console by\n      // enabling \"pause on exceptions\" in your JavaScript debugger.\n      throw new Error(message); // eslint-disable-next-line no-empty\n    } catch (e) {}\n  }\n}\n\nvar BeforeUnloadEventType = 'beforeunload';\nvar HashChangeEventType = 'hashchange';\nvar PopStateEventType = 'popstate';\n/**\r\n * Browser history stores the location in regular URLs. This is the standard for\r\n * most web apps, but it requires some configuration on the server to ensure you\r\n * serve the same app at multiple URLs.\r\n *\r\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createbrowserhistory\r\n */\n\nfunction createBrowserHistory(options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var _options = options,\n      _options$window = _options.window,\n      window = _options$window === void 0 ? document.defaultView : _options$window;\n  var globalHistory = window.history;\n\n  function getIndexAndLocation() {\n    var _window$location = window.location,\n        pathname = _window$location.pathname,\n        search = _window$location.search,\n        hash = _window$location.hash;\n    var state = globalHistory.state || {};\n    return [state.idx, readOnly({\n      pathname: pathname,\n      search: search,\n      hash: hash,\n      state: state.usr || null,\n      key: state.key || 'default'\n    })];\n  }\n\n  var blockedPopTx = null;\n\n  function handlePop() {\n    if (blockedPopTx) {\n      blockers.call(blockedPopTx);\n      blockedPopTx = null;\n    } else {\n      var nextAction = Action.Pop;\n\n      var _getIndexAndLocation = getIndexAndLocation(),\n          nextIndex = _getIndexAndLocation[0],\n          nextLocation = _getIndexAndLocation[1];\n\n      if (blockers.length) {\n        if (nextIndex != null) {\n          var delta = index - nextIndex;\n\n          if (delta) {\n            // Revert the POP\n            blockedPopTx = {\n              action: nextAction,\n              location: nextLocation,\n              retry: function retry() {\n                go(delta * -1);\n              }\n            };\n            go(delta);\n          }\n        } else {\n          // Trying to POP to a location with no index. We did not create\n          // this location, so we can't effectively block the navigation.\n          process.env.NODE_ENV !== \"production\" ? warning(false, // TODO: Write up a doc that explains our blocking strategy in\n          // detail and link to it here so people can understand better what\n          // is going on and how to avoid it.\n          \"You are trying to block a POP navigation to a location that was not \" + \"created by the history library. The block will fail silently in \" + \"production, but in general you should do all navigation with the \" + \"history library (instead of using window.history.pushState directly) \" + \"to avoid this situation.\") : void 0;\n        }\n      } else {\n        applyTx(nextAction);\n      }\n    }\n  }\n\n  window.addEventListener(PopStateEventType, handlePop);\n  var action = Action.Pop;\n\n  var _getIndexAndLocation2 = getIndexAndLocation(),\n      index = _getIndexAndLocation2[0],\n      location = _getIndexAndLocation2[1];\n\n  var listeners = createEvents();\n  var blockers = createEvents();\n\n  if (index == null) {\n    index = 0;\n    globalHistory.replaceState(_extends({}, globalHistory.state, {\n      idx: index\n    }), '');\n  }\n\n  function createHref(to) {\n    return typeof to === 'string' ? to : createPath(to);\n  } // state defaults to `null` because `window.history.state` does\n\n\n  function getNextLocation(to, state) {\n    if (state === void 0) {\n      state = null;\n    }\n\n    return readOnly(_extends({\n      pathname: location.pathname,\n      hash: '',\n      search: ''\n    }, typeof to === 'string' ? parsePath(to) : to, {\n      state: state,\n      key: createKey()\n    }));\n  }\n\n  function getHistoryStateAndUrl(nextLocation, index) {\n    return [{\n      usr: nextLocation.state,\n      key: nextLocation.key,\n      idx: index\n    }, createHref(nextLocation)];\n  }\n\n  function allowTx(action, location, retry) {\n    return !blockers.length || (blockers.call({\n      action: action,\n      location: location,\n      retry: retry\n    }), false);\n  }\n\n  function applyTx(nextAction) {\n    action = nextAction;\n\n    var _getIndexAndLocation3 = getIndexAndLocation();\n\n    index = _getIndexAndLocation3[0];\n    location = _getIndexAndLocation3[1];\n    listeners.call({\n      action: action,\n      location: location\n    });\n  }\n\n  function push(to, state) {\n    var nextAction = Action.Push;\n    var nextLocation = getNextLocation(to, state);\n\n    function retry() {\n      push(to, state);\n    }\n\n    if (allowTx(nextAction, nextLocation, retry)) {\n      var _getHistoryStateAndUr = getHistoryStateAndUrl(nextLocation, index + 1),\n          historyState = _getHistoryStateAndUr[0],\n          url = _getHistoryStateAndUr[1]; // TODO: Support forced reloading\n      // try...catch because iOS limits us to 100 pushState calls :/\n\n\n      try {\n        globalHistory.pushState(historyState, '', url);\n      } catch (error) {\n        // They are going to lose state here, but there is no real\n        // way to warn them about it since the page will refresh...\n        window.location.assign(url);\n      }\n\n      applyTx(nextAction);\n    }\n  }\n\n  function replace(to, state) {\n    var nextAction = Action.Replace;\n    var nextLocation = getNextLocation(to, state);\n\n    function retry() {\n      replace(to, state);\n    }\n\n    if (allowTx(nextAction, nextLocation, retry)) {\n      var _getHistoryStateAndUr2 = getHistoryStateAndUrl(nextLocation, index),\n          historyState = _getHistoryStateAndUr2[0],\n          url = _getHistoryStateAndUr2[1]; // TODO: Support forced reloading\n\n\n      globalHistory.replaceState(historyState, '', url);\n      applyTx(nextAction);\n    }\n  }\n\n  function go(delta) {\n    globalHistory.go(delta);\n  }\n\n  var history = {\n    get action() {\n      return action;\n    },\n\n    get location() {\n      return location;\n    },\n\n    createHref: createHref,\n    push: push,\n    replace: replace,\n    go: go,\n    back: function back() {\n      go(-1);\n    },\n    forward: function forward() {\n      go(1);\n    },\n    listen: function listen(listener) {\n      return listeners.push(listener);\n    },\n    block: function block(blocker) {\n      var unblock = blockers.push(blocker);\n\n      if (blockers.length === 1) {\n        window.addEventListener(BeforeUnloadEventType, promptBeforeUnload);\n      }\n\n      return function () {\n        unblock(); // Remove the beforeunload listener so the document may\n        // still be salvageable in the pagehide event.\n        // See https://html.spec.whatwg.org/#unloading-documents\n\n        if (!blockers.length) {\n          window.removeEventListener(BeforeUnloadEventType, promptBeforeUnload);\n        }\n      };\n    }\n  };\n  return history;\n}\n/**\r\n * Hash history stores the location in window.location.hash. This makes it ideal\r\n * for situations where you don't want to send the location to the server for\r\n * some reason, either because you do cannot configure it or the URL space is\r\n * reserved for something else.\r\n *\r\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createhashhistory\r\n */\n\nfunction createHashHistory(options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var _options2 = options,\n      _options2$window = _options2.window,\n      window = _options2$window === void 0 ? document.defaultView : _options2$window;\n  var globalHistory = window.history;\n\n  function getIndexAndLocation() {\n    var _parsePath = parsePath(window.location.hash.substr(1)),\n        _parsePath$pathname = _parsePath.pathname,\n        pathname = _parsePath$pathname === void 0 ? '/' : _parsePath$pathname,\n        _parsePath$search = _parsePath.search,\n        search = _parsePath$search === void 0 ? '' : _parsePath$search,\n        _parsePath$hash = _parsePath.hash,\n        hash = _parsePath$hash === void 0 ? '' : _parsePath$hash;\n\n    var state = globalHistory.state || {};\n    return [state.idx, readOnly({\n      pathname: pathname,\n      search: search,\n      hash: hash,\n      state: state.usr || null,\n      key: state.key || 'default'\n    })];\n  }\n\n  var blockedPopTx = null;\n\n  function handlePop() {\n    if (blockedPopTx) {\n      blockers.call(blockedPopTx);\n      blockedPopTx = null;\n    } else {\n      var nextAction = Action.Pop;\n\n      var _getIndexAndLocation4 = getIndexAndLocation(),\n          nextIndex = _getIndexAndLocation4[0],\n          nextLocation = _getIndexAndLocation4[1];\n\n      if (blockers.length) {\n        if (nextIndex != null) {\n          var delta = index - nextIndex;\n\n          if (delta) {\n            // Revert the POP\n            blockedPopTx = {\n              action: nextAction,\n              location: nextLocation,\n              retry: function retry() {\n                go(delta * -1);\n              }\n            };\n            go(delta);\n          }\n        } else {\n          // Trying to POP to a location with no index. We did not create\n          // this location, so we can't effectively block the navigation.\n          process.env.NODE_ENV !== \"production\" ? warning(false, // TODO: Write up a doc that explains our blocking strategy in\n          // detail and link to it here so people can understand better\n          // what is going on and how to avoid it.\n          \"You are trying to block a POP navigation to a location that was not \" + \"created by the history library. The block will fail silently in \" + \"production, but in general you should do all navigation with the \" + \"history library (instead of using window.history.pushState directly) \" + \"to avoid this situation.\") : void 0;\n        }\n      } else {\n        applyTx(nextAction);\n      }\n    }\n  }\n\n  window.addEventListener(PopStateEventType, handlePop); // popstate does not fire on hashchange in IE 11 and old (trident) Edge\n  // https://developer.mozilla.org/de/docs/Web/API/Window/popstate_event\n\n  window.addEventListener(HashChangeEventType, function () {\n    var _getIndexAndLocation5 = getIndexAndLocation(),\n        nextLocation = _getIndexAndLocation5[1]; // Ignore extraneous hashchange events.\n\n\n    if (createPath(nextLocation) !== createPath(location)) {\n      handlePop();\n    }\n  });\n  var action = Action.Pop;\n\n  var _getIndexAndLocation6 = getIndexAndLocation(),\n      index = _getIndexAndLocation6[0],\n      location = _getIndexAndLocation6[1];\n\n  var listeners = createEvents();\n  var blockers = createEvents();\n\n  if (index == null) {\n    index = 0;\n    globalHistory.replaceState(_extends({}, globalHistory.state, {\n      idx: index\n    }), '');\n  }\n\n  function getBaseHref() {\n    var base = document.querySelector('base');\n    var href = '';\n\n    if (base && base.getAttribute('href')) {\n      var url = window.location.href;\n      var hashIndex = url.indexOf('#');\n      href = hashIndex === -1 ? url : url.slice(0, hashIndex);\n    }\n\n    return href;\n  }\n\n  function createHref(to) {\n    return getBaseHref() + '#' + (typeof to === 'string' ? to : createPath(to));\n  }\n\n  function getNextLocation(to, state) {\n    if (state === void 0) {\n      state = null;\n    }\n\n    return readOnly(_extends({\n      pathname: location.pathname,\n      hash: '',\n      search: ''\n    }, typeof to === 'string' ? parsePath(to) : to, {\n      state: state,\n      key: createKey()\n    }));\n  }\n\n  function getHistoryStateAndUrl(nextLocation, index) {\n    return [{\n      usr: nextLocation.state,\n      key: nextLocation.key,\n      idx: index\n    }, createHref(nextLocation)];\n  }\n\n  function allowTx(action, location, retry) {\n    return !blockers.length || (blockers.call({\n      action: action,\n      location: location,\n      retry: retry\n    }), false);\n  }\n\n  function applyTx(nextAction) {\n    action = nextAction;\n\n    var _getIndexAndLocation7 = getIndexAndLocation();\n\n    index = _getIndexAndLocation7[0];\n    location = _getIndexAndLocation7[1];\n    listeners.call({\n      action: action,\n      location: location\n    });\n  }\n\n  function push(to, state) {\n    var nextAction = Action.Push;\n    var nextLocation = getNextLocation(to, state);\n\n    function retry() {\n      push(to, state);\n    }\n\n    process.env.NODE_ENV !== \"production\" ? warning(nextLocation.pathname.charAt(0) === '/', \"Relative pathnames are not supported in hash history.push(\" + JSON.stringify(to) + \")\") : void 0;\n\n    if (allowTx(nextAction, nextLocation, retry)) {\n      var _getHistoryStateAndUr3 = getHistoryStateAndUrl(nextLocation, index + 1),\n          historyState = _getHistoryStateAndUr3[0],\n          url = _getHistoryStateAndUr3[1]; // TODO: Support forced reloading\n      // try...catch because iOS limits us to 100 pushState calls :/\n\n\n      try {\n        globalHistory.pushState(historyState, '', url);\n      } catch (error) {\n        // They are going to lose state here, but there is no real\n        // way to warn them about it since the page will refresh...\n        window.location.assign(url);\n      }\n\n      applyTx(nextAction);\n    }\n  }\n\n  function replace(to, state) {\n    var nextAction = Action.Replace;\n    var nextLocation = getNextLocation(to, state);\n\n    function retry() {\n      replace(to, state);\n    }\n\n    process.env.NODE_ENV !== \"production\" ? warning(nextLocation.pathname.charAt(0) === '/', \"Relative pathnames are not supported in hash history.replace(\" + JSON.stringify(to) + \")\") : void 0;\n\n    if (allowTx(nextAction, nextLocation, retry)) {\n      var _getHistoryStateAndUr4 = getHistoryStateAndUrl(nextLocation, index),\n          historyState = _getHistoryStateAndUr4[0],\n          url = _getHistoryStateAndUr4[1]; // TODO: Support forced reloading\n\n\n      globalHistory.replaceState(historyState, '', url);\n      applyTx(nextAction);\n    }\n  }\n\n  function go(delta) {\n    globalHistory.go(delta);\n  }\n\n  var history = {\n    get action() {\n      return action;\n    },\n\n    get location() {\n      return location;\n    },\n\n    createHref: createHref,\n    push: push,\n    replace: replace,\n    go: go,\n    back: function back() {\n      go(-1);\n    },\n    forward: function forward() {\n      go(1);\n    },\n    listen: function listen(listener) {\n      return listeners.push(listener);\n    },\n    block: function block(blocker) {\n      var unblock = blockers.push(blocker);\n\n      if (blockers.length === 1) {\n        window.addEventListener(BeforeUnloadEventType, promptBeforeUnload);\n      }\n\n      return function () {\n        unblock(); // Remove the beforeunload listener so the document may\n        // still be salvageable in the pagehide event.\n        // See https://html.spec.whatwg.org/#unloading-documents\n\n        if (!blockers.length) {\n          window.removeEventListener(BeforeUnloadEventType, promptBeforeUnload);\n        }\n      };\n    }\n  };\n  return history;\n}\n/**\r\n * Memory history stores the current location in memory. It is designed for use\r\n * in stateful non-browser environments like tests and React Native.\r\n *\r\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#creatememoryhistory\r\n */\n\nfunction createMemoryHistory(options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var _options3 = options,\n      _options3$initialEntr = _options3.initialEntries,\n      initialEntries = _options3$initialEntr === void 0 ? ['/'] : _options3$initialEntr,\n      initialIndex = _options3.initialIndex;\n  var entries = initialEntries.map(function (entry) {\n    var location = readOnly(_extends({\n      pathname: '/',\n      search: '',\n      hash: '',\n      state: null,\n      key: createKey()\n    }, typeof entry === 'string' ? parsePath(entry) : entry));\n    process.env.NODE_ENV !== \"production\" ? warning(location.pathname.charAt(0) === '/', \"Relative pathnames are not supported in createMemoryHistory({ initialEntries }) (invalid entry: \" + JSON.stringify(entry) + \")\") : void 0;\n    return location;\n  });\n  var index = clamp(initialIndex == null ? entries.length - 1 : initialIndex, 0, entries.length - 1);\n  var action = Action.Pop;\n  var location = entries[index];\n  var listeners = createEvents();\n  var blockers = createEvents();\n\n  function createHref(to) {\n    return typeof to === 'string' ? to : createPath(to);\n  }\n\n  function getNextLocation(to, state) {\n    if (state === void 0) {\n      state = null;\n    }\n\n    return readOnly(_extends({\n      pathname: location.pathname,\n      search: '',\n      hash: ''\n    }, typeof to === 'string' ? parsePath(to) : to, {\n      state: state,\n      key: createKey()\n    }));\n  }\n\n  function allowTx(action, location, retry) {\n    return !blockers.length || (blockers.call({\n      action: action,\n      location: location,\n      retry: retry\n    }), false);\n  }\n\n  function applyTx(nextAction, nextLocation) {\n    action = nextAction;\n    location = nextLocation;\n    listeners.call({\n      action: action,\n      location: location\n    });\n  }\n\n  function push(to, state) {\n    var nextAction = Action.Push;\n    var nextLocation = getNextLocation(to, state);\n\n    function retry() {\n      push(to, state);\n    }\n\n    process.env.NODE_ENV !== \"production\" ? warning(location.pathname.charAt(0) === '/', \"Relative pathnames are not supported in memory history.push(\" + JSON.stringify(to) + \")\") : void 0;\n\n    if (allowTx(nextAction, nextLocation, retry)) {\n      index += 1;\n      entries.splice(index, entries.length, nextLocation);\n      applyTx(nextAction, nextLocation);\n    }\n  }\n\n  function replace(to, state) {\n    var nextAction = Action.Replace;\n    var nextLocation = getNextLocation(to, state);\n\n    function retry() {\n      replace(to, state);\n    }\n\n    process.env.NODE_ENV !== \"production\" ? warning(location.pathname.charAt(0) === '/', \"Relative pathnames are not supported in memory history.replace(\" + JSON.stringify(to) + \")\") : void 0;\n\n    if (allowTx(nextAction, nextLocation, retry)) {\n      entries[index] = nextLocation;\n      applyTx(nextAction, nextLocation);\n    }\n  }\n\n  function go(delta) {\n    var nextIndex = clamp(index + delta, 0, entries.length - 1);\n    var nextAction = Action.Pop;\n    var nextLocation = entries[nextIndex];\n\n    function retry() {\n      go(delta);\n    }\n\n    if (allowTx(nextAction, nextLocation, retry)) {\n      index = nextIndex;\n      applyTx(nextAction, nextLocation);\n    }\n  }\n\n  var history = {\n    get index() {\n      return index;\n    },\n\n    get action() {\n      return action;\n    },\n\n    get location() {\n      return location;\n    },\n\n    createHref: createHref,\n    push: push,\n    replace: replace,\n    go: go,\n    back: function back() {\n      go(-1);\n    },\n    forward: function forward() {\n      go(1);\n    },\n    listen: function listen(listener) {\n      return listeners.push(listener);\n    },\n    block: function block(blocker) {\n      return blockers.push(blocker);\n    }\n  };\n  return history;\n} ////////////////////////////////////////////////////////////////////////////////\n// UTILS\n////////////////////////////////////////////////////////////////////////////////\n\nfunction clamp(n, lowerBound, upperBound) {\n  return Math.min(Math.max(n, lowerBound), upperBound);\n}\n\nfunction promptBeforeUnload(event) {\n  // Cancel the event.\n  event.preventDefault(); // Chrome (and legacy IE) requires returnValue to be set.\n\n  event.returnValue = '';\n}\n\nfunction createEvents() {\n  var handlers = [];\n  return {\n    get length() {\n      return handlers.length;\n    },\n\n    push: function push(fn) {\n      handlers.push(fn);\n      return function () {\n        handlers = handlers.filter(function (handler) {\n          return handler !== fn;\n        });\n      };\n    },\n    call: function call(arg) {\n      handlers.forEach(function (fn) {\n        return fn && fn(arg);\n      });\n    }\n  };\n}\n\nfunction createKey() {\n  return Math.random().toString(36).substr(2, 8);\n}\n/**\r\n * Creates a string URL path from the given pathname, search, and hash components.\r\n *\r\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createpath\r\n */\n\n\nfunction createPath(_ref) {\n  var _ref$pathname = _ref.pathname,\n      pathname = _ref$pathname === void 0 ? '/' : _ref$pathname,\n      _ref$search = _ref.search,\n      search = _ref$search === void 0 ? '' : _ref$search,\n      _ref$hash = _ref.hash,\n      hash = _ref$hash === void 0 ? '' : _ref$hash;\n  if (search && search !== '?') pathname += search.charAt(0) === '?' ? search : '?' + search;\n  if (hash && hash !== '#') pathname += hash.charAt(0) === '#' ? hash : '#' + hash;\n  return pathname;\n}\n/**\r\n * Parses a string URL path into its separate pathname, search, and hash components.\r\n *\r\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#parsepath\r\n */\n\nfunction parsePath(path) {\n  var parsedPath = {};\n\n  if (path) {\n    var hashIndex = path.indexOf('#');\n\n    if (hashIndex >= 0) {\n      parsedPath.hash = path.substr(hashIndex);\n      path = path.substr(0, hashIndex);\n    }\n\n    var searchIndex = path.indexOf('?');\n\n    if (searchIndex >= 0) {\n      parsedPath.search = path.substr(searchIndex);\n      path = path.substr(0, searchIndex);\n    }\n\n    if (path) {\n      parsedPath.pathname = path;\n    }\n  }\n\n  return parsedPath;\n}\n\nexport { Action, createBrowserHistory, createHashHistory, createMemoryHistory, createPath, parsePath };\n//# sourceMappingURL=index.js.map\n", "import * as React from \"react\";\nimport type {\n  Hash,\n  History,\n  InitialEntry,\n  Location,\n  MemoryHistory,\n  Path,\n  Pathname,\n  Search,\n  To,\n} from \"history\";\nimport {\n  Action as NavigationType,\n  createMemoryHistory,\n  parsePath,\n  createPath,\n} from \"history\";\n\nexport { parsePath, createPath, NavigationType };\nexport type { Hash, Location, Path, Pathname, Search, To };\n\nfunction invariant(cond: any, message: string): asserts cond {\n  if (!cond) throw new Error(message);\n}\n\nfunction warning(cond: any, message: string): void {\n  if (!cond) {\n    // eslint-disable-next-line no-console\n    if (typeof console !== \"undefined\") console.warn(message);\n\n    try {\n      // Welcome to debugging React Router!\n      //\n      // This error is thrown as a convenience so you can more easily\n      // find the source for a warning that appears in the console by\n      // enabling \"pause on exceptions\" in your JavaScript debugger.\n      throw new Error(message);\n      // eslint-disable-next-line no-empty\n    } catch (e) {}\n  }\n}\n\nconst alreadyWarned: Record<string, boolean> = {};\nfunction warningOnce(key: string, cond: boolean, message: string) {\n  if (!cond && !alreadyWarned[key]) {\n    alreadyWarned[key] = true;\n    warning(false, message);\n  }\n}\n\n///////////////////////////////////////////////////////////////////////////////\n// CONTEXT\n///////////////////////////////////////////////////////////////////////////////\n\n/**\n * A Navigator is a \"location changer\"; it's how you get to different locations.\n *\n * Every history instance conforms to the Navigator interface, but the\n * distinction is useful primarily when it comes to the low-level <Router> API\n * where both the location and a navigator must be provided separately in order\n * to avoid \"tearing\" that may occur in a suspense-enabled app if the action\n * and/or location were to be read directly from the history instance.\n */\nexport type Navigator = Pick<History, \"go\" | \"push\" | \"replace\" | \"createHref\">;\n\ninterface NavigationContextObject {\n  basename: string;\n  navigator: Navigator;\n  static: boolean;\n}\n\nconst NavigationContext = React.createContext<NavigationContextObject>(null!);\n\nif (__DEV__) {\n  NavigationContext.displayName = \"Navigation\";\n}\n\ninterface LocationContextObject {\n  location: Location;\n  navigationType: NavigationType;\n}\n\nconst LocationContext = React.createContext<LocationContextObject>(null!);\n\nif (__DEV__) {\n  LocationContext.displayName = \"Location\";\n}\n\ninterface RouteContextObject {\n  outlet: React.ReactElement | null;\n  matches: RouteMatch[];\n}\n\nconst RouteContext = React.createContext<RouteContextObject>({\n  outlet: null,\n  matches: [],\n});\n\nif (__DEV__) {\n  RouteContext.displayName = \"Route\";\n}\n\n///////////////////////////////////////////////////////////////////////////////\n// COMPONENTS\n///////////////////////////////////////////////////////////////////////////////\n\nexport interface MemoryRouterProps {\n  basename?: string;\n  children?: React.ReactNode;\n  initialEntries?: InitialEntry[];\n  initialIndex?: number;\n}\n\n/**\n * A <Router> that stores all entries in memory.\n *\n * @see https://reactrouter.com/docs/en/v6/api#memoryrouter\n */\nexport function MemoryRouter({\n  basename,\n  children,\n  initialEntries,\n  initialIndex,\n}: MemoryRouterProps): React.ReactElement {\n  let historyRef = React.useRef<MemoryHistory>();\n  if (historyRef.current == null) {\n    historyRef.current = createMemoryHistory({ initialEntries, initialIndex });\n  }\n\n  let history = historyRef.current;\n  let [state, setState] = React.useState({\n    action: history.action,\n    location: history.location,\n  });\n\n  React.useLayoutEffect(() => history.listen(setState), [history]);\n\n  return (\n    <Router\n      basename={basename}\n      children={children}\n      location={state.location}\n      navigationType={state.action}\n      navigator={history}\n    />\n  );\n}\n\nexport interface NavigateProps {\n  to: To;\n  replace?: boolean;\n  state?: any;\n}\n\n/**\n * Changes the current location.\n *\n * Note: This API is mostly useful in React.Component subclasses that are not\n * able to use hooks. In functional components, we recommend you use the\n * `useNavigate` hook instead.\n *\n * @see https://reactrouter.com/docs/en/v6/api#navigate\n */\nexport function Navigate({ to, replace, state }: NavigateProps): null {\n  invariant(\n    useInRouterContext(),\n    // TODO: This error is probably because they somehow have 2 versions of\n    // the router loaded. We can help them understand how to avoid that.\n    `<Navigate> may be used only in the context of a <Router> component.`\n  );\n\n  warning(\n    !React.useContext(NavigationContext).static,\n    `<Navigate> must not be used on the initial render in a <StaticRouter>. ` +\n      `This is a no-op, but you should modify your code so the <Navigate> is ` +\n      `only ever rendered in response to some user interaction or state change.`\n  );\n\n  let navigate = useNavigate();\n  React.useEffect(() => {\n    navigate(to, { replace, state });\n  });\n\n  return null;\n}\n\nexport interface OutletProps {\n  context?: unknown;\n}\n\n/**\n * Renders the child route's element, if there is one.\n *\n * @see https://reactrouter.com/docs/en/v6/api#outlet\n */\nexport function Outlet(props: OutletProps): React.ReactElement | null {\n  return useOutlet(props.context);\n}\n\nexport interface RouteProps {\n  caseSensitive?: boolean;\n  children?: React.ReactNode;\n  element?: React.ReactNode | null;\n  index?: boolean;\n  path?: string;\n}\n\nexport interface PathRouteProps {\n  caseSensitive?: boolean;\n  children?: React.ReactNode;\n  element?: React.ReactNode | null;\n  index?: false;\n  path: string;\n}\n\nexport interface LayoutRouteProps {\n  children?: React.ReactNode;\n  element?: React.ReactNode | null;\n}\n\nexport interface IndexRouteProps {\n  element?: React.ReactNode | null;\n  index: true;\n}\n\n/**\n * Declares an element that should be rendered at a certain URL path.\n *\n * @see https://reactrouter.com/docs/en/v6/api#route\n */\nexport function Route(\n  _props: PathRouteProps | LayoutRouteProps | IndexRouteProps\n): React.ReactElement | null {\n  invariant(\n    false,\n    `A <Route> is only ever to be used as the child of <Routes> element, ` +\n      `never rendered directly. Please wrap your <Route> in a <Routes>.`\n  );\n}\n\nexport interface RouterProps {\n  basename?: string;\n  children?: React.ReactNode;\n  location: Partial<Location> | string;\n  navigationType?: NavigationType;\n  navigator: Navigator;\n  static?: boolean;\n}\n\n/**\n * Provides location context for the rest of the app.\n *\n * Note: You usually won't render a <Router> directly. Instead, you'll render a\n * router that is more specific to your environment such as a <BrowserRouter>\n * in web browsers or a <StaticRouter> for server rendering.\n *\n * @see https://reactrouter.com/docs/en/v6/api#router\n */\nexport function Router({\n  basename: basenameProp = \"/\",\n  children = null,\n  location: locationProp,\n  navigationType = NavigationType.Pop,\n  navigator,\n  static: staticProp = false,\n}: RouterProps): React.ReactElement | null {\n  invariant(\n    !useInRouterContext(),\n    `You cannot render a <Router> inside another <Router>.` +\n      ` You should never have more than one in your app.`\n  );\n\n  let basename = normalizePathname(basenameProp);\n  let navigationContext = React.useMemo(\n    () => ({ basename, navigator, static: staticProp }),\n    [basename, navigator, staticProp]\n  );\n\n  if (typeof locationProp === \"string\") {\n    locationProp = parsePath(locationProp);\n  }\n\n  let {\n    pathname = \"/\",\n    search = \"\",\n    hash = \"\",\n    state = null,\n    key = \"default\",\n  } = locationProp;\n\n  let location = React.useMemo(() => {\n    let trailingPathname = stripBasename(pathname, basename);\n\n    if (trailingPathname == null) {\n      return null;\n    }\n\n    return {\n      pathname: trailingPathname,\n      search,\n      hash,\n      state,\n      key,\n    };\n  }, [basename, pathname, search, hash, state, key]);\n\n  warning(\n    location != null,\n    `<Router basename=\"${basename}\"> is not able to match the URL ` +\n      `\"${pathname}${search}${hash}\" because it does not start with the ` +\n      `basename, so the <Router> won't render anything.`\n  );\n\n  if (location == null) {\n    return null;\n  }\n\n  return (\n    <NavigationContext.Provider value={navigationContext}>\n      <LocationContext.Provider\n        children={children}\n        value={{ location, navigationType }}\n      />\n    </NavigationContext.Provider>\n  );\n}\n\nexport interface RoutesProps {\n  children?: React.ReactNode;\n  location?: Partial<Location> | string;\n}\n\n/**\n * A container for a nested tree of <Route> elements that renders the branch\n * that best matches the current location.\n *\n * @see https://reactrouter.com/docs/en/v6/api#routes\n */\nexport function Routes({\n  children,\n  location,\n}: RoutesProps): React.ReactElement | null {\n  return useRoutes(createRoutesFromChildren(children), location);\n}\n\n///////////////////////////////////////////////////////////////////////////////\n// HOOKS\n///////////////////////////////////////////////////////////////////////////////\n\n/**\n * Returns the full href for the given \"to\" value. This is useful for building\n * custom links that are also accessible and preserve right-click behavior.\n *\n * @see https://reactrouter.com/docs/en/v6/api#usehref\n */\nexport function useHref(to: To): string {\n  invariant(\n    useInRouterContext(),\n    // TODO: This error is probably because they somehow have 2 versions of the\n    // router loaded. We can help them understand how to avoid that.\n    `useHref() may be used only in the context of a <Router> component.`\n  );\n\n  let { basename, navigator } = React.useContext(NavigationContext);\n  let { hash, pathname, search } = useResolvedPath(to);\n\n  let joinedPathname = pathname;\n  if (basename !== \"/\") {\n    let toPathname = getToPathname(to);\n    let endsWithSlash = toPathname != null && toPathname.endsWith(\"/\");\n    joinedPathname =\n      pathname === \"/\"\n        ? basename + (endsWithSlash ? \"/\" : \"\")\n        : joinPaths([basename, pathname]);\n  }\n\n  return navigator.createHref({ pathname: joinedPathname, search, hash });\n}\n\n/**\n * Returns true if this component is a descendant of a <Router>.\n *\n * @see https://reactrouter.com/docs/en/v6/api#useinroutercontext\n */\nexport function useInRouterContext(): boolean {\n  return React.useContext(LocationContext) != null;\n}\n\n/**\n * Returns the current location object, which represents the current URL in web\n * browsers.\n *\n * Note: If you're using this it may mean you're doing some of your own\n * \"routing\" in your app, and we'd like to know what your use case is. We may\n * be able to provide something higher-level to better suit your needs.\n *\n * @see https://reactrouter.com/docs/en/v6/api#uselocation\n */\nexport function useLocation(): Location {\n  invariant(\n    useInRouterContext(),\n    // TODO: This error is probably because they somehow have 2 versions of the\n    // router loaded. We can help them understand how to avoid that.\n    `useLocation() may be used only in the context of a <Router> component.`\n  );\n\n  return React.useContext(LocationContext).location;\n}\n\ntype ParamParseFailed = { failed: true };\n\ntype ParamParseSegment<Segment extends string> =\n  // Check here if there exists a forward slash in the string.\n  Segment extends `${infer LeftSegment}/${infer RightSegment}`\n    ? // If there is a forward slash, then attempt to parse each side of the\n      // forward slash.\n      ParamParseSegment<LeftSegment> extends infer LeftResult\n      ? ParamParseSegment<RightSegment> extends infer RightResult\n        ? LeftResult extends string\n          ? // If the left side is successfully parsed as a param, then check if\n            // the right side can be successfully parsed as well. If both sides\n            // can be parsed, then the result is a union of the two sides\n            // (read: \"foo\" | \"bar\").\n            RightResult extends string\n            ? LeftResult | RightResult\n            : LeftResult\n          : // If the left side is not successfully parsed as a param, then check\n          // if only the right side can be successfully parse as a param. If it\n          // can, then the result is just right, else it's a failure.\n          RightResult extends string\n          ? RightResult\n          : ParamParseFailed\n        : ParamParseFailed\n      : // If the left side didn't parse into a param, then just check the right\n      // side.\n      ParamParseSegment<RightSegment> extends infer RightResult\n      ? RightResult extends string\n        ? RightResult\n        : ParamParseFailed\n      : ParamParseFailed\n    : // If there's no forward slash, then check if this segment starts with a\n    // colon. If it does, then this is a dynamic segment, so the result is\n    // just the remainder of the string. Otherwise, it's a failure.\n    Segment extends `:${infer Remaining}`\n    ? Remaining\n    : ParamParseFailed;\n\n// Attempt to parse the given string segment. If it fails, then just return the\n// plain string type as a default fallback. Otherwise return the union of the\n// parsed string literals that were referenced as dynamic segments in the route.\ntype ParamParseKey<Segment extends string> =\n  ParamParseSegment<Segment> extends string\n    ? ParamParseSegment<Segment>\n    : string;\n\n/**\n * Returns the current navigation action which describes how the router came to\n * the current location, either by a pop, push, or replace on the history stack.\n *\n * @see https://reactrouter.com/docs/en/v6/api#usenavigationtype\n */\nexport function useNavigationType(): NavigationType {\n  return React.useContext(LocationContext).navigationType;\n}\n\n/**\n * Returns true if the URL for the given \"to\" value matches the current URL.\n * This is useful for components that need to know \"active\" state, e.g.\n * <NavLink>.\n *\n * @see https://reactrouter.com/docs/en/v6/api#usematch\n */\nexport function useMatch<\n  ParamKey extends ParamParseKey<Path>,\n  Path extends string\n>(pattern: PathPattern<Path> | Path): PathMatch<ParamKey> | null {\n  invariant(\n    useInRouterContext(),\n    // TODO: This error is probably because they somehow have 2 versions of the\n    // router loaded. We can help them understand how to avoid that.\n    `useMatch() may be used only in the context of a <Router> component.`\n  );\n\n  let { pathname } = useLocation();\n  return React.useMemo(\n    () => matchPath<ParamKey, Path>(pattern, pathname),\n    [pathname, pattern]\n  );\n}\n\n/**\n * The interface for the navigate() function returned from useNavigate().\n */\nexport interface NavigateFunction {\n  (to: To, options?: NavigateOptions): void;\n  (delta: number): void;\n}\n\nexport interface NavigateOptions {\n  replace?: boolean;\n  state?: any;\n}\n\n/**\n * Returns an imperative method for changing the location. Used by <Link>s, but\n * may also be used by other elements to change the location.\n *\n * @see https://reactrouter.com/docs/en/v6/api#usenavigate\n */\nexport function useNavigate(): NavigateFunction {\n  invariant(\n    useInRouterContext(),\n    // TODO: This error is probably because they somehow have 2 versions of the\n    // router loaded. We can help them understand how to avoid that.\n    `useNavigate() may be used only in the context of a <Router> component.`\n  );\n\n  let { basename, navigator } = React.useContext(NavigationContext);\n  let { matches } = React.useContext(RouteContext);\n  let { pathname: locationPathname } = useLocation();\n\n  let routePathnamesJson = JSON.stringify(\n    matches.map((match) => match.pathnameBase)\n  );\n\n  let activeRef = React.useRef(false);\n  React.useEffect(() => {\n    activeRef.current = true;\n  });\n\n  let navigate: NavigateFunction = React.useCallback(\n    (to: To | number, options: NavigateOptions = {}) => {\n      warning(\n        activeRef.current,\n        `You should call navigate() in a React.useEffect(), not when ` +\n          `your component is first rendered.`\n      );\n\n      if (!activeRef.current) return;\n\n      if (typeof to === \"number\") {\n        navigator.go(to);\n        return;\n      }\n\n      let path = resolveTo(\n        to,\n        JSON.parse(routePathnamesJson),\n        locationPathname\n      );\n\n      if (basename !== \"/\") {\n        path.pathname = joinPaths([basename, path.pathname]);\n      }\n\n      (!!options.replace ? navigator.replace : navigator.push)(\n        path,\n        options.state\n      );\n    },\n    [basename, navigator, routePathnamesJson, locationPathname]\n  );\n\n  return navigate;\n}\n\nconst OutletContext = React.createContext<unknown>(null);\n\n/**\n * Returns the context (if provided) for the child route at this level of the route\n * hierarchy.\n * @see https://reactrouter.com/docs/en/v6/api#useoutletcontext\n */\nexport function useOutletContext<Context = unknown>(): Context {\n  return React.useContext(OutletContext) as Context;\n}\n\n/**\n * Returns the element for the child route at this level of the route\n * hierarchy. Used internally by <Outlet> to render child routes.\n *\n * @see https://reactrouter.com/docs/en/v6/api#useoutlet\n */\nexport function useOutlet(context?: unknown): React.ReactElement | null {\n  let outlet = React.useContext(RouteContext).outlet;\n  if (outlet) {\n    return (\n      <OutletContext.Provider value={context}>{outlet}</OutletContext.Provider>\n    );\n  }\n  return outlet;\n}\n\n/**\n * Returns an object of key/value pairs of the dynamic params from the current\n * URL that were matched by the route path.\n *\n * @see https://reactrouter.com/docs/en/v6/api#useparams\n */\nexport function useParams<\n  ParamsOrKey extends string | Record<string, string | undefined> = string\n>(): Readonly<\n  [ParamsOrKey] extends [string] ? Params<ParamsOrKey> : Partial<ParamsOrKey>\n> {\n  let { matches } = React.useContext(RouteContext);\n  let routeMatch = matches[matches.length - 1];\n  return routeMatch ? (routeMatch.params as any) : {};\n}\n\n/**\n * Resolves the pathname of the given `to` value against the current location.\n *\n * @see https://reactrouter.com/docs/en/v6/api#useresolvedpath\n */\nexport function useResolvedPath(to: To): Path {\n  let { matches } = React.useContext(RouteContext);\n  let { pathname: locationPathname } = useLocation();\n\n  let routePathnamesJson = JSON.stringify(\n    matches.map((match) => match.pathnameBase)\n  );\n\n  return React.useMemo(\n    () => resolveTo(to, JSON.parse(routePathnamesJson), locationPathname),\n    [to, routePathnamesJson, locationPathname]\n  );\n}\n\n/**\n * Returns the element of the route that matched the current location, prepared\n * with the correct context to render the remainder of the route tree. Route\n * elements in the tree must render an <Outlet> to render their child route's\n * element.\n *\n * @see https://reactrouter.com/docs/en/v6/api#useroutes\n */\nexport function useRoutes(\n  routes: RouteObject[],\n  locationArg?: Partial<Location> | string\n): React.ReactElement | null {\n  invariant(\n    useInRouterContext(),\n    // TODO: This error is probably because they somehow have 2 versions of the\n    // router loaded. We can help them understand how to avoid that.\n    `useRoutes() may be used only in the context of a <Router> component.`\n  );\n\n  let { matches: parentMatches } = React.useContext(RouteContext);\n  let routeMatch = parentMatches[parentMatches.length - 1];\n  let parentParams = routeMatch ? routeMatch.params : {};\n  let parentPathname = routeMatch ? routeMatch.pathname : \"/\";\n  let parentPathnameBase = routeMatch ? routeMatch.pathnameBase : \"/\";\n  let parentRoute = routeMatch && routeMatch.route;\n\n  if (__DEV__) {\n    // You won't get a warning about 2 different <Routes> under a <Route>\n    // without a trailing *, but this is a best-effort warning anyway since we\n    // cannot even give the warning unless they land at the parent route.\n    //\n    // Example:\n    //\n    // <Routes>\n    //   {/* This route path MUST end with /* because otherwise\n    //       it will never match /blog/post/123 */}\n    //   <Route path=\"blog\" element={<Blog />} />\n    //   <Route path=\"blog/feed\" element={<BlogFeed />} />\n    // </Routes>\n    //\n    // function Blog() {\n    //   return (\n    //     <Routes>\n    //       <Route path=\"post/:id\" element={<Post />} />\n    //     </Routes>\n    //   );\n    // }\n    let parentPath = (parentRoute && parentRoute.path) || \"\";\n    warningOnce(\n      parentPathname,\n      !parentRoute || parentPath.endsWith(\"*\"),\n      `You rendered descendant <Routes> (or called \\`useRoutes()\\`) at ` +\n        `\"${parentPathname}\" (under <Route path=\"${parentPath}\">) but the ` +\n        `parent route path has no trailing \"*\". This means if you navigate ` +\n        `deeper, the parent won't match anymore and therefore the child ` +\n        `routes will never render.\\n\\n` +\n        `Please change the parent <Route path=\"${parentPath}\"> to <Route ` +\n        `path=\"${parentPath === \"/\" ? \"*\" : `${parentPath}/*`}\">.`\n    );\n  }\n\n  let locationFromContext = useLocation();\n\n  let location;\n  if (locationArg) {\n    let parsedLocationArg =\n      typeof locationArg === \"string\" ? parsePath(locationArg) : locationArg;\n\n    invariant(\n      parentPathnameBase === \"/\" ||\n        parsedLocationArg.pathname?.startsWith(parentPathnameBase),\n      `When overriding the location using \\`<Routes location>\\` or \\`useRoutes(routes, location)\\`, ` +\n        `the location pathname must begin with the portion of the URL pathname that was ` +\n        `matched by all parent routes. The current pathname base is \"${parentPathnameBase}\" ` +\n        `but pathname \"${parsedLocationArg.pathname}\" was given in the \\`location\\` prop.`\n    );\n\n    location = parsedLocationArg;\n  } else {\n    location = locationFromContext;\n  }\n\n  let pathname = location.pathname || \"/\";\n  let remainingPathname =\n    parentPathnameBase === \"/\"\n      ? pathname\n      : pathname.slice(parentPathnameBase.length) || \"/\";\n  let matches = matchRoutes(routes, { pathname: remainingPathname });\n\n  if (__DEV__) {\n    warning(\n      parentRoute || matches != null,\n      `No routes matched location \"${location.pathname}${location.search}${location.hash}\" `\n    );\n\n    warning(\n      matches == null ||\n        matches[matches.length - 1].route.element !== undefined,\n      `Matched leaf route at location \"${location.pathname}${location.search}${location.hash}\" does not have an element. ` +\n        `This means it will render an <Outlet /> with a null value by default resulting in an \"empty\" page.`\n    );\n  }\n\n  return _renderMatches(\n    matches &&\n      matches.map((match) =>\n        Object.assign({}, match, {\n          params: Object.assign({}, parentParams, match.params),\n          pathname: joinPaths([parentPathnameBase, match.pathname]),\n          pathnameBase:\n            match.pathnameBase === \"/\"\n              ? parentPathnameBase\n              : joinPaths([parentPathnameBase, match.pathnameBase]),\n        })\n      ),\n    parentMatches\n  );\n}\n\n///////////////////////////////////////////////////////////////////////////////\n// UTILS\n///////////////////////////////////////////////////////////////////////////////\n\n/**\n * Creates a route config from a React \"children\" object, which is usually\n * either a `<Route>` element or an array of them. Used internally by\n * `<Routes>` to create a route config from its children.\n *\n * @see https://reactrouter.com/docs/en/v6/api#createroutesfromchildren\n */\nexport function createRoutesFromChildren(\n  children: React.ReactNode\n): RouteObject[] {\n  let routes: RouteObject[] = [];\n\n  React.Children.forEach(children, (element) => {\n    if (!React.isValidElement(element)) {\n      // Ignore non-elements. This allows people to more easily inline\n      // conditionals in their route config.\n      return;\n    }\n\n    if (element.type === React.Fragment) {\n      // Transparently support React.Fragment and its children.\n      routes.push.apply(\n        routes,\n        createRoutesFromChildren(element.props.children)\n      );\n      return;\n    }\n\n    invariant(\n      element.type === Route,\n      `[${\n        typeof element.type === \"string\" ? element.type : element.type.name\n      }] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>`\n    );\n\n    let route: RouteObject = {\n      caseSensitive: element.props.caseSensitive,\n      element: element.props.element,\n      index: element.props.index,\n      path: element.props.path,\n    };\n\n    if (element.props.children) {\n      route.children = createRoutesFromChildren(element.props.children);\n    }\n\n    routes.push(route);\n  });\n\n  return routes;\n}\n\n/**\n * The parameters that were parsed from the URL path.\n */\nexport type Params<Key extends string = string> = {\n  readonly [key in Key]: string | undefined;\n};\n\n/**\n * A route object represents a logical route, with (optionally) its child\n * routes organized in a tree-like structure.\n */\nexport interface RouteObject {\n  caseSensitive?: boolean;\n  children?: RouteObject[];\n  element?: React.ReactNode;\n  index?: boolean;\n  path?: string;\n}\n\n/**\n * Returns a path with params interpolated.\n *\n * @see https://reactrouter.com/docs/en/v6/api#generatepath\n */\nexport function generatePath(path: string, params: Params = {}): string {\n  return path\n    .replace(/:(\\w+)/g, (_, key) => {\n      invariant(params[key] != null, `Missing \":${key}\" param`);\n      return params[key]!;\n    })\n    .replace(/\\/*\\*$/, (_) =>\n      params[\"*\"] == null ? \"\" : params[\"*\"].replace(/^\\/*/, \"/\")\n    );\n}\n\n/**\n * A RouteMatch contains info about how a route matched a URL.\n */\nexport interface RouteMatch<ParamKey extends string = string> {\n  /**\n   * The names and values of dynamic parameters in the URL.\n   */\n  params: Params<ParamKey>;\n  /**\n   * The portion of the URL pathname that was matched.\n   */\n  pathname: string;\n  /**\n   * The portion of the URL pathname that was matched before child routes.\n   */\n  pathnameBase: string;\n  /**\n   * The route object that was used to match.\n   */\n  route: RouteObject;\n}\n\n/**\n * Matches the given routes to a location and returns the match data.\n *\n * @see https://reactrouter.com/docs/en/v6/api#matchroutes\n */\nexport function matchRoutes(\n  routes: RouteObject[],\n  locationArg: Partial<Location> | string,\n  basename = \"/\"\n): RouteMatch[] | null {\n  let location =\n    typeof locationArg === \"string\" ? parsePath(locationArg) : locationArg;\n\n  let pathname = stripBasename(location.pathname || \"/\", basename);\n\n  if (pathname == null) {\n    return null;\n  }\n\n  let branches = flattenRoutes(routes);\n  rankRouteBranches(branches);\n\n  let matches = null;\n  for (let i = 0; matches == null && i < branches.length; ++i) {\n    matches = matchRouteBranch(branches[i], pathname);\n  }\n\n  return matches;\n}\n\ninterface RouteMeta {\n  relativePath: string;\n  caseSensitive: boolean;\n  childrenIndex: number;\n  route: RouteObject;\n}\n\ninterface RouteBranch {\n  path: string;\n  score: number;\n  routesMeta: RouteMeta[];\n}\n\nfunction flattenRoutes(\n  routes: RouteObject[],\n  branches: RouteBranch[] = [],\n  parentsMeta: RouteMeta[] = [],\n  parentPath = \"\"\n): RouteBranch[] {\n  routes.forEach((route, index) => {\n    let meta: RouteMeta = {\n      relativePath: route.path || \"\",\n      caseSensitive: route.caseSensitive === true,\n      childrenIndex: index,\n      route,\n    };\n\n    if (meta.relativePath.startsWith(\"/\")) {\n      invariant(\n        meta.relativePath.startsWith(parentPath),\n        `Absolute route path \"${meta.relativePath}\" nested under path ` +\n          `\"${parentPath}\" is not valid. An absolute child route path ` +\n          `must start with the combined path of all its parent routes.`\n      );\n\n      meta.relativePath = meta.relativePath.slice(parentPath.length);\n    }\n\n    let path = joinPaths([parentPath, meta.relativePath]);\n    let routesMeta = parentsMeta.concat(meta);\n\n    // Add the children before adding this route to the array so we traverse the\n    // route tree depth-first and child routes appear before their parents in\n    // the \"flattened\" version.\n    if (route.children && route.children.length > 0) {\n      invariant(\n        route.index !== true,\n        `Index routes must not have child routes. Please remove ` +\n          `all child routes from route path \"${path}\".`\n      );\n\n      flattenRoutes(route.children, branches, routesMeta, path);\n    }\n\n    // Routes without a path shouldn't ever match by themselves unless they are\n    // index routes, so don't add them to the list of possible branches.\n    if (route.path == null && !route.index) {\n      return;\n    }\n\n    branches.push({ path, score: computeScore(path, route.index), routesMeta });\n  });\n\n  return branches;\n}\n\nfunction rankRouteBranches(branches: RouteBranch[]): void {\n  branches.sort((a, b) =>\n    a.score !== b.score\n      ? b.score - a.score // Higher score first\n      : compareIndexes(\n          a.routesMeta.map((meta) => meta.childrenIndex),\n          b.routesMeta.map((meta) => meta.childrenIndex)\n        )\n  );\n}\n\nconst paramRe = /^:\\w+$/;\nconst dynamicSegmentValue = 3;\nconst indexRouteValue = 2;\nconst emptySegmentValue = 1;\nconst staticSegmentValue = 10;\nconst splatPenalty = -2;\nconst isSplat = (s: string) => s === \"*\";\n\nfunction computeScore(path: string, index: boolean | undefined): number {\n  let segments = path.split(\"/\");\n  let initialScore = segments.length;\n  if (segments.some(isSplat)) {\n    initialScore += splatPenalty;\n  }\n\n  if (index) {\n    initialScore += indexRouteValue;\n  }\n\n  return segments\n    .filter((s) => !isSplat(s))\n    .reduce(\n      (score, segment) =>\n        score +\n        (paramRe.test(segment)\n          ? dynamicSegmentValue\n          : segment === \"\"\n          ? emptySegmentValue\n          : staticSegmentValue),\n      initialScore\n    );\n}\n\nfunction compareIndexes(a: number[], b: number[]): number {\n  let siblings =\n    a.length === b.length && a.slice(0, -1).every((n, i) => n === b[i]);\n\n  return siblings\n    ? // If two routes are siblings, we should try to match the earlier sibling\n      // first. This allows people to have fine-grained control over the matching\n      // behavior by simply putting routes with identical paths in the order they\n      // want them tried.\n      a[a.length - 1] - b[b.length - 1]\n    : // Otherwise, it doesn't really make sense to rank non-siblings by index,\n      // so they sort equally.\n      0;\n}\n\nfunction matchRouteBranch<ParamKey extends string = string>(\n  branch: RouteBranch,\n  pathname: string\n): RouteMatch<ParamKey>[] | null {\n  let { routesMeta } = branch;\n\n  let matchedParams = {};\n  let matchedPathname = \"/\";\n  let matches: RouteMatch[] = [];\n  for (let i = 0; i < routesMeta.length; ++i) {\n    let meta = routesMeta[i];\n    let end = i === routesMeta.length - 1;\n    let remainingPathname =\n      matchedPathname === \"/\"\n        ? pathname\n        : pathname.slice(matchedPathname.length) || \"/\";\n    let match = matchPath(\n      { path: meta.relativePath, caseSensitive: meta.caseSensitive, end },\n      remainingPathname\n    );\n\n    if (!match) return null;\n\n    Object.assign(matchedParams, match.params);\n\n    let route = meta.route;\n\n    matches.push({\n      params: matchedParams,\n      pathname: joinPaths([matchedPathname, match.pathname]),\n      pathnameBase: normalizePathname(\n        joinPaths([matchedPathname, match.pathnameBase])\n      ),\n      route,\n    });\n\n    if (match.pathnameBase !== \"/\") {\n      matchedPathname = joinPaths([matchedPathname, match.pathnameBase]);\n    }\n  }\n\n  return matches;\n}\n\n/**\n * Renders the result of `matchRoutes()` into a React element.\n */\nexport function renderMatches(\n  matches: RouteMatch[] | null\n): React.ReactElement | null {\n  return _renderMatches(matches);\n}\n\nfunction _renderMatches(\n  matches: RouteMatch[] | null,\n  parentMatches: RouteMatch[] = []\n): React.ReactElement | null {\n  if (matches == null) return null;\n\n  return matches.reduceRight((outlet, match, index) => {\n    return (\n      <RouteContext.Provider\n        children={\n          match.route.element !== undefined ? match.route.element : outlet\n        }\n        value={{\n          outlet,\n          matches: parentMatches.concat(matches.slice(0, index + 1)),\n        }}\n      />\n    );\n  }, null as React.ReactElement | null);\n}\n\n/**\n * A PathPattern is used to match on some portion of a URL pathname.\n */\nexport interface PathPattern<Path extends string = string> {\n  /**\n   * A string to match against a URL pathname. May contain `:id`-style segments\n   * to indicate placeholders for dynamic parameters. May also end with `/*` to\n   * indicate matching the rest of the URL pathname.\n   */\n  path: Path;\n  /**\n   * Should be `true` if the static portions of the `path` should be matched in\n   * the same case.\n   */\n  caseSensitive?: boolean;\n  /**\n   * Should be `true` if this pattern should match the entire URL pathname.\n   */\n  end?: boolean;\n}\n\n/**\n * A PathMatch contains info about how a PathPattern matched on a URL pathname.\n */\nexport interface PathMatch<ParamKey extends string = string> {\n  /**\n   * The names and values of dynamic parameters in the URL.\n   */\n  params: Params<ParamKey>;\n  /**\n   * The portion of the URL pathname that was matched.\n   */\n  pathname: string;\n  /**\n   * The portion of the URL pathname that was matched before child routes.\n   */\n  pathnameBase: string;\n  /**\n   * The pattern that was used to match.\n   */\n  pattern: PathPattern;\n}\n\ntype Mutable<T> = {\n  -readonly [P in keyof T]: T[P];\n};\n\n/**\n * Performs pattern matching on a URL pathname and returns information about\n * the match.\n *\n * @see https://reactrouter.com/docs/en/v6/api#matchpath\n */\nexport function matchPath<\n  ParamKey extends ParamParseKey<Path>,\n  Path extends string\n>(\n  pattern: PathPattern<Path> | Path,\n  pathname: string\n): PathMatch<ParamKey> | null {\n  if (typeof pattern === \"string\") {\n    pattern = { path: pattern, caseSensitive: false, end: true };\n  }\n\n  let [matcher, paramNames] = compilePath(\n    pattern.path,\n    pattern.caseSensitive,\n    pattern.end\n  );\n\n  let match = pathname.match(matcher);\n  if (!match) return null;\n\n  let matchedPathname = match[0];\n  let pathnameBase = matchedPathname.replace(/(.)\\/+$/, \"$1\");\n  let captureGroups = match.slice(1);\n  let params: Params = paramNames.reduce<Mutable<Params>>(\n    (memo, paramName, index) => {\n      // We need to compute the pathnameBase here using the raw splat value\n      // instead of using params[\"*\"] later because it will be decoded then\n      if (paramName === \"*\") {\n        let splatValue = captureGroups[index] || \"\";\n        pathnameBase = matchedPathname\n          .slice(0, matchedPathname.length - splatValue.length)\n          .replace(/(.)\\/+$/, \"$1\");\n      }\n\n      memo[paramName] = safelyDecodeURIComponent(\n        captureGroups[index] || \"\",\n        paramName\n      );\n      return memo;\n    },\n    {}\n  );\n\n  return {\n    params,\n    pathname: matchedPathname,\n    pathnameBase,\n    pattern,\n  };\n}\n\nfunction compilePath(\n  path: string,\n  caseSensitive = false,\n  end = true\n): [RegExp, string[]] {\n  warning(\n    path === \"*\" || !path.endsWith(\"*\") || path.endsWith(\"/*\"),\n    `Route path \"${path}\" will be treated as if it were ` +\n      `\"${path.replace(/\\*$/, \"/*\")}\" because the \\`*\\` character must ` +\n      `always follow a \\`/\\` in the pattern. To get rid of this warning, ` +\n      `please change the route path to \"${path.replace(/\\*$/, \"/*\")}\".`\n  );\n\n  let paramNames: string[] = [];\n  let regexpSource =\n    \"^\" +\n    path\n      .replace(/\\/*\\*?$/, \"\") // Ignore trailing / and /*, we'll handle it below\n      .replace(/^\\/*/, \"/\") // Make sure it has a leading /\n      .replace(/[\\\\.*+^$?{}|()[\\]]/g, \"\\\\$&\") // Escape special regex chars\n      .replace(/:(\\w+)/g, (_: string, paramName: string) => {\n        paramNames.push(paramName);\n        return \"([^\\\\/]+)\";\n      });\n\n  if (path.endsWith(\"*\")) {\n    paramNames.push(\"*\");\n    regexpSource +=\n      path === \"*\" || path === \"/*\"\n        ? \"(.*)$\" // Already matched the initial /, just match the rest\n        : \"(?:\\\\/(.+)|\\\\/*)$\"; // Don't include the / in params[\"*\"]\n  } else {\n    regexpSource += end\n      ? \"\\\\/*$\" // When matching to the end, ignore trailing slashes\n      : // Otherwise, match a word boundary or a proceeding /. The word boundary restricts\n        // parent routes to matching only their own words and nothing more, e.g. parent\n        // route \"/home\" should not match \"/home2\".\n        // Additionally, allow paths starting with `.`, `-`, `~`, and url-encoded entities,\n        // but do not consume the character in the matched path so they can match against\n        // nested paths.\n        \"(?:(?=[.~-]|%[0-9A-F]{2})|\\\\b|\\\\/|$)\";\n  }\n\n  let matcher = new RegExp(regexpSource, caseSensitive ? undefined : \"i\");\n\n  return [matcher, paramNames];\n}\n\nfunction safelyDecodeURIComponent(value: string, paramName: string) {\n  try {\n    return decodeURIComponent(value);\n  } catch (error) {\n    warning(\n      false,\n      `The value for the URL param \"${paramName}\" will not be decoded because` +\n        ` the string \"${value}\" is a malformed URL segment. This is probably` +\n        ` due to a bad percent encoding (${error}).`\n    );\n\n    return value;\n  }\n}\n\n/**\n * Returns a resolved path object relative to the given pathname.\n *\n * @see https://reactrouter.com/docs/en/v6/api#resolvepath\n */\nexport function resolvePath(to: To, fromPathname = \"/\"): Path {\n  let {\n    pathname: toPathname,\n    search = \"\",\n    hash = \"\",\n  } = typeof to === \"string\" ? parsePath(to) : to;\n\n  let pathname = toPathname\n    ? toPathname.startsWith(\"/\")\n      ? toPathname\n      : resolvePathname(toPathname, fromPathname)\n    : fromPathname;\n\n  return {\n    pathname,\n    search: normalizeSearch(search),\n    hash: normalizeHash(hash),\n  };\n}\n\nfunction resolvePathname(relativePath: string, fromPathname: string): string {\n  let segments = fromPathname.replace(/\\/+$/, \"\").split(\"/\");\n  let relativeSegments = relativePath.split(\"/\");\n\n  relativeSegments.forEach((segment) => {\n    if (segment === \"..\") {\n      // Keep the root \"\" segment so the pathname starts at /\n      if (segments.length > 1) segments.pop();\n    } else if (segment !== \".\") {\n      segments.push(segment);\n    }\n  });\n\n  return segments.length > 1 ? segments.join(\"/\") : \"/\";\n}\n\nfunction resolveTo(\n  toArg: To,\n  routePathnames: string[],\n  locationPathname: string\n): Path {\n  let to = typeof toArg === \"string\" ? parsePath(toArg) : toArg;\n  let toPathname = toArg === \"\" || to.pathname === \"\" ? \"/\" : to.pathname;\n\n  // If a pathname is explicitly provided in `to`, it should be relative to the\n  // route context. This is explained in `Note on `<Link to>` values` in our\n  // migration guide from v5 as a means of disambiguation between `to` values\n  // that begin with `/` and those that do not. However, this is problematic for\n  // `to` values that do not provide a pathname. `to` can simply be a search or\n  // hash string, in which case we should assume that the navigation is relative\n  // to the current location's pathname and *not* the route pathname.\n  let from: string;\n  if (toPathname == null) {\n    from = locationPathname;\n  } else {\n    let routePathnameIndex = routePathnames.length - 1;\n\n    if (toPathname.startsWith(\"..\")) {\n      let toSegments = toPathname.split(\"/\");\n\n      // Each leading .. segment means \"go up one route\" instead of \"go up one\n      // URL segment\".  This is a key difference from how <a href> works and a\n      // major reason we call this a \"to\" value instead of a \"href\".\n      while (toSegments[0] === \"..\") {\n        toSegments.shift();\n        routePathnameIndex -= 1;\n      }\n\n      to.pathname = toSegments.join(\"/\");\n    }\n\n    // If there are more \"..\" segments than parent routes, resolve relative to\n    // the root / URL.\n    from = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : \"/\";\n  }\n\n  let path = resolvePath(to, from);\n\n  // Ensure the pathname has a trailing slash if the original to value had one.\n  if (\n    toPathname &&\n    toPathname !== \"/\" &&\n    toPathname.endsWith(\"/\") &&\n    !path.pathname.endsWith(\"/\")\n  ) {\n    path.pathname += \"/\";\n  }\n\n  return path;\n}\n\nfunction getToPathname(to: To): string | undefined {\n  // Empty strings should be treated the same as / paths\n  return to === \"\" || (to as Path).pathname === \"\"\n    ? \"/\"\n    : typeof to === \"string\"\n    ? parsePath(to).pathname\n    : to.pathname;\n}\n\nfunction stripBasename(pathname: string, basename: string): string | null {\n  if (basename === \"/\") return pathname;\n\n  if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {\n    return null;\n  }\n\n  let nextChar = pathname.charAt(basename.length);\n  if (nextChar && nextChar !== \"/\") {\n    // pathname does not start with basename/\n    return null;\n  }\n\n  return pathname.slice(basename.length) || \"/\";\n}\n\nconst joinPaths = (paths: string[]): string =>\n  paths.join(\"/\").replace(/\\/\\/+/g, \"/\");\n\nconst normalizePathname = (pathname: string): string =>\n  pathname.replace(/\\/+$/, \"\").replace(/^\\/*/, \"/\");\n\nconst normalizeSearch = (search: string): string =>\n  !search || search === \"?\"\n    ? \"\"\n    : search.startsWith(\"?\")\n    ? search\n    : \"?\" + search;\n\nconst normalizeHash = (hash: string): string =>\n  !hash || hash === \"#\" ? \"\" : hash.startsWith(\"#\") ? hash : \"#\" + hash;\n\n///////////////////////////////////////////////////////////////////////////////\n// DANGER! PLEASE READ ME!\n// We provide these exports as an escape hatch in the event that you need any\n// routing data that we don't provide an explicit API for. With that said, we\n// want to cover your use case if we can, so if you feel the need to use these\n// we want to hear from you. Let us know what you're building and we'll do our\n// best to make sure we can support you!\n//\n// We consider these exports an implementation detail and do not guarantee\n// against any breaking changes, regardless of the semver release. Use with\n// extreme caution and only if you understand the consequences. Godspeed.\n///////////////////////////////////////////////////////////////////////////////\n\n/** @internal */\nexport {\n  NavigationContext as UNSAFE_NavigationContext,\n  LocationContext as UNSAFE_LocationContext,\n  RouteContext as UNSAFE_RouteContext,\n};\n", "import * as React from \"react\";\nimport type { BrowserHistory, HashHistory, History } from \"history\";\nimport { createBrowserHistory, createHashHistory } from \"history\";\nimport {\n  MemoryRouter,\n  Navigate,\n  Outlet,\n  Route,\n  Router,\n  Routes,\n  createRoutesFromChildren,\n  generatePath,\n  matchRoutes,\n  matchPath,\n  createPath,\n  parsePath,\n  resolvePath,\n  renderMatches,\n  useHref,\n  useInRouterContext,\n  useLocation,\n  useMatch,\n  useNavigate,\n  useNavigationType,\n  useOutlet,\n  useParams,\n  useResolvedPath,\n  useRoutes,\n  useOutletContext,\n} from \"react-router\";\nimport type { To } from \"react-router\";\n\nfunction warning(cond: boolean, message: string): void {\n  if (!cond) {\n    // eslint-disable-next-line no-console\n    if (typeof console !== \"undefined\") console.warn(message);\n\n    try {\n      // Welcome to debugging React Router!\n      //\n      // This error is thrown as a convenience so you can more easily\n      // find the source for a warning that appears in the console by\n      // enabling \"pause on exceptions\" in your JavaScript debugger.\n      throw new Error(message);\n      // eslint-disable-next-line no-empty\n    } catch (e) {}\n  }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// RE-EXPORTS\n////////////////////////////////////////////////////////////////////////////////\n\n// Note: Keep in sync with react-router exports!\nexport {\n  MemoryRouter,\n  Navigate,\n  Outlet,\n  Route,\n  Router,\n  Routes,\n  createRoutesFromChildren,\n  generatePath,\n  matchRoutes,\n  matchPath,\n  createPath,\n  parsePath,\n  renderMatches,\n  resolvePath,\n  useHref,\n  useInRouterContext,\n  useLocation,\n  useMatch,\n  useNavigate,\n  useNavigationType,\n  useOutlet,\n  useParams,\n  useResolvedPath,\n  useRoutes,\n  useOutletContext,\n};\n\nexport { NavigationType } from \"react-router\";\nexport type {\n  Hash,\n  Location,\n  Path,\n  To,\n  MemoryRouterProps,\n  NavigateFunction,\n  NavigateOptions,\n  NavigateProps,\n  Navigator,\n  OutletProps,\n  Params,\n  PathMatch,\n  RouteMatch,\n  RouteObject,\n  RouteProps,\n  PathRouteProps,\n  LayoutRouteProps,\n  IndexRouteProps,\n  RouterProps,\n  Pathname,\n  Search,\n  RoutesProps,\n} from \"react-router\";\n\n///////////////////////////////////////////////////////////////////////////////\n// DANGER! PLEASE READ ME!\n// We provide these exports as an escape hatch in the event that you need any\n// routing data that we don't provide an explicit API for. With that said, we\n// want to cover your use case if we can, so if you feel the need to use these\n// we want to hear from you. Let us know what you're building and we'll do our\n// best to make sure we can support you!\n//\n// We consider these exports an implementation detail and do not guarantee\n// against any breaking changes, regardless of the semver release. Use with\n// extreme caution and only if you understand the consequences. Godspeed.\n///////////////////////////////////////////////////////////////////////////////\n\n/** @internal */\nexport {\n  UNSAFE_NavigationContext,\n  UNSAFE_LocationContext,\n  UNSAFE_RouteContext,\n} from \"react-router\";\n\n////////////////////////////////////////////////////////////////////////////////\n// COMPONENTS\n////////////////////////////////////////////////////////////////////////////////\n\nexport interface BrowserRouterProps {\n  basename?: string;\n  children?: React.ReactNode;\n  window?: Window;\n}\n\n/**\n * A `<Router>` for use in web browsers. Provides the cleanest URLs.\n */\nexport function BrowserRouter({\n  basename,\n  children,\n  window,\n}: BrowserRouterProps) {\n  let historyRef = React.useRef<BrowserHistory>();\n  if (historyRef.current == null) {\n    historyRef.current = createBrowserHistory({ window });\n  }\n\n  let history = historyRef.current;\n  let [state, setState] = React.useState({\n    action: history.action,\n    location: history.location,\n  });\n\n  React.useLayoutEffect(() => history.listen(setState), [history]);\n\n  return (\n    <Router\n      basename={basename}\n      children={children}\n      location={state.location}\n      navigationType={state.action}\n      navigator={history}\n    />\n  );\n}\n\nexport interface HashRouterProps {\n  basename?: string;\n  children?: React.ReactNode;\n  window?: Window;\n}\n\n/**\n * A `<Router>` for use in web browsers. Stores the location in the hash\n * portion of the URL so it is not sent to the server.\n */\nexport function HashRouter({ basename, children, window }: HashRouterProps) {\n  let historyRef = React.useRef<HashHistory>();\n  if (historyRef.current == null) {\n    historyRef.current = createHashHistory({ window });\n  }\n\n  let history = historyRef.current;\n  let [state, setState] = React.useState({\n    action: history.action,\n    location: history.location,\n  });\n\n  React.useLayoutEffect(() => history.listen(setState), [history]);\n\n  return (\n    <Router\n      basename={basename}\n      children={children}\n      location={state.location}\n      navigationType={state.action}\n      navigator={history}\n    />\n  );\n}\n\nexport interface HistoryRouterProps {\n  basename?: string;\n  children?: React.ReactNode;\n  history: History;\n}\n\n/**\n * A `<Router>` that accepts a pre-instantiated history object. It's important\n * to note that using your own history object is highly discouraged and may add\n * two versions of the history library to your bundles unless you use the same\n * version of the history library that React Router uses internally.\n */\nfunction HistoryRouter({ basename, children, history }: HistoryRouterProps) {\n  const [state, setState] = React.useState({\n    action: history.action,\n    location: history.location,\n  });\n\n  React.useLayoutEffect(() => history.listen(setState), [history]);\n\n  return (\n    <Router\n      basename={basename}\n      children={children}\n      location={state.location}\n      navigationType={state.action}\n      navigator={history}\n    />\n  );\n}\n\nif (__DEV__) {\n  HistoryRouter.displayName = \"unstable_HistoryRouter\";\n}\n\nexport { HistoryRouter as unstable_HistoryRouter };\n\nfunction isModifiedEvent(event: React.MouseEvent) {\n  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);\n}\n\nexport interface LinkProps\n  extends Omit<React.AnchorHTMLAttributes<HTMLAnchorElement>, \"href\"> {\n  reloadDocument?: boolean;\n  replace?: boolean;\n  state?: any;\n  to: To;\n}\n\n/**\n * The public API for rendering a history-aware <a>.\n */\nexport const Link = React.forwardRef<HTMLAnchorElement, LinkProps>(\n  function LinkWithRef(\n    { onClick, reloadDocument, replace = false, state, target, to, ...rest },\n    ref\n  ) {\n    let href = useHref(to);\n    let internalOnClick = useLinkClickHandler(to, { replace, state, target });\n    function handleClick(\n      event: React.MouseEvent<HTMLAnchorElement, MouseEvent>\n    ) {\n      if (onClick) onClick(event);\n      if (!event.defaultPrevented && !reloadDocument) {\n        internalOnClick(event);\n      }\n    }\n\n    return (\n      // eslint-disable-next-line jsx-a11y/anchor-has-content\n      <a\n        {...rest}\n        href={href}\n        onClick={handleClick}\n        ref={ref}\n        target={target}\n      />\n    );\n  }\n);\n\nif (__DEV__) {\n  Link.displayName = \"Link\";\n}\n\nexport interface NavLinkProps\n  extends Omit<LinkProps, \"className\" | \"style\" | \"children\"> {\n  children:\n    | React.ReactNode\n    | ((props: { isActive: boolean }) => React.ReactNode);\n  caseSensitive?: boolean;\n  className?: string | ((props: { isActive: boolean }) => string | undefined);\n  end?: boolean;\n  style?:\n    | React.CSSProperties\n    | ((props: { isActive: boolean }) => React.CSSProperties);\n}\n\n/**\n * A <Link> wrapper that knows if it's \"active\" or not.\n */\nexport const NavLink = React.forwardRef<HTMLAnchorElement, NavLinkProps>(\n  function NavLinkWithRef(\n    {\n      \"aria-current\": ariaCurrentProp = \"page\",\n      caseSensitive = false,\n      className: classNameProp = \"\",\n      end = false,\n      style: styleProp,\n      to,\n      children,\n      ...rest\n    },\n    ref\n  ) {\n    let location = useLocation();\n    let path = useResolvedPath(to);\n\n    let locationPathname = location.pathname;\n    let toPathname = path.pathname;\n    if (!caseSensitive) {\n      locationPathname = locationPathname.toLowerCase();\n      toPathname = toPathname.toLowerCase();\n    }\n\n    let isActive =\n      locationPathname === toPathname ||\n      (!end &&\n        locationPathname.startsWith(toPathname) &&\n        locationPathname.charAt(toPathname.length) === \"/\");\n\n    let ariaCurrent = isActive ? ariaCurrentProp : undefined;\n\n    let className: string | undefined;\n    if (typeof classNameProp === \"function\") {\n      className = classNameProp({ isActive });\n    } else {\n      // If the className prop is not a function, we use a default `active`\n      // class for <NavLink />s that are active. In v5 `active` was the default\n      // value for `activeClassName`, but we are removing that API and can still\n      // use the old default behavior for a cleaner upgrade path and keep the\n      // simple styling rules working as they currently do.\n      className = [classNameProp, isActive ? \"active\" : null]\n        .filter(Boolean)\n        .join(\" \");\n    }\n\n    let style =\n      typeof styleProp === \"function\" ? styleProp({ isActive }) : styleProp;\n\n    return (\n      <Link\n        {...rest}\n        aria-current={ariaCurrent}\n        className={className}\n        ref={ref}\n        style={style}\n        to={to}\n      >\n        {typeof children === \"function\" ? children({ isActive }) : children}\n      </Link>\n    );\n  }\n);\n\nif (__DEV__) {\n  NavLink.displayName = \"NavLink\";\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// HOOKS\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * Handles the click behavior for router `<Link>` components. This is useful if\n * you need to create custom `<Link>` components with the same click behavior we\n * use in our exported `<Link>`.\n */\nexport function useLinkClickHandler<E extends Element = HTMLAnchorElement>(\n  to: To,\n  {\n    target,\n    replace: replaceProp,\n    state,\n  }: {\n    target?: React.HTMLAttributeAnchorTarget;\n    replace?: boolean;\n    state?: any;\n  } = {}\n): (event: React.MouseEvent<E, MouseEvent>) => void {\n  let navigate = useNavigate();\n  let location = useLocation();\n  let path = useResolvedPath(to);\n\n  return React.useCallback(\n    (event: React.MouseEvent<E, MouseEvent>) => {\n      if (\n        event.button === 0 && // Ignore everything but left clicks\n        (!target || target === \"_self\") && // Let browser handle \"target=_blank\" etc.\n        !isModifiedEvent(event) // Ignore clicks with modifier keys\n      ) {\n        event.preventDefault();\n\n        // If the URL hasn't changed, a regular <a> will do a replace instead of\n        // a push, so do the same here.\n        let replace =\n          !!replaceProp || createPath(location) === createPath(path);\n\n        navigate(to, { replace, state });\n      }\n    },\n    [location, navigate, path, replaceProp, state, target, to]\n  );\n}\n\n/**\n * A convenient wrapper for reading and writing search parameters via the\n * URLSearchParams interface.\n */\nexport function useSearchParams(defaultInit?: URLSearchParamsInit) {\n  warning(\n    typeof URLSearchParams !== \"undefined\",\n    `You cannot use the \\`useSearchParams\\` hook in a browser that does not ` +\n      `support the URLSearchParams API. If you need to support Internet ` +\n      `Explorer 11, we recommend you load a polyfill such as ` +\n      `https://github.com/ungap/url-search-params\\n\\n` +\n      `If you're unsure how to load polyfills, we recommend you check out ` +\n      `https://polyfill.io/v3/ which provides some recommendations about how ` +\n      `to load polyfills only for users that need them, instead of for every ` +\n      `user.`\n  );\n\n  let defaultSearchParamsRef = React.useRef(createSearchParams(defaultInit));\n\n  let location = useLocation();\n  let searchParams = React.useMemo(() => {\n    let searchParams = createSearchParams(location.search);\n\n    for (let key of defaultSearchParamsRef.current.keys()) {\n      if (!searchParams.has(key)) {\n        defaultSearchParamsRef.current.getAll(key).forEach((value) => {\n          searchParams.append(key, value);\n        });\n      }\n    }\n\n    return searchParams;\n  }, [location.search]);\n\n  let navigate = useNavigate();\n  let setSearchParams = React.useCallback(\n    (\n      nextInit: URLSearchParamsInit,\n      navigateOptions?: { replace?: boolean; state?: any }\n    ) => {\n      navigate(\"?\" + createSearchParams(nextInit), navigateOptions);\n    },\n    [navigate]\n  );\n\n  return [searchParams, setSearchParams] as const;\n}\n\nexport type ParamKeyValuePair = [string, string];\n\nexport type URLSearchParamsInit =\n  | string\n  | ParamKeyValuePair[]\n  | Record<string, string | string[]>\n  | URLSearchParams;\n\n/**\n * Creates a URLSearchParams object using the given initializer.\n *\n * This is identical to `new URLSearchParams(init)` except it also\n * supports arrays as values in the object form of the initializer\n * instead of just strings. This is convenient when you need multiple\n * values for a given key, but don't want to use an array initializer.\n *\n * For example, instead of:\n *\n *   let searchParams = new URLSearchParams([\n *     ['sort', 'name'],\n *     ['sort', 'price']\n *   ]);\n *\n * you can do:\n *\n *   let searchParams = createSearchParams({\n *     sort: ['name', 'price']\n *   });\n */\nexport function createSearchParams(\n  init: URLSearchParamsInit = \"\"\n): URLSearchParams {\n  return new URLSearchParams(\n    typeof init === \"string\" ||\n    Array.isArray(init) ||\n    init instanceof URLSearchParams\n      ? init\n      : Object.keys(init).reduce((memo, key) => {\n          let value = init[key];\n          return memo.concat(\n            Array.isArray(value) ? value.map((v) => [key, v]) : [[key, value]]\n          );\n        }, [] as ParamKeyValuePair[])\n  );\n}\n", "/*!\n * cookie\n * Copyright(c) 2012-2014 Roman Shtylman\n * Copyright(c) 2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict';\n\n/**\n * Module exports.\n * @public\n */\n\nexports.parse = parse;\nexports.serialize = serialize;\n\n/**\n * Module variables.\n * @private\n */\n\nvar decode = decodeURIComponent;\nvar encode = encodeURIComponent;\n\n/**\n * RegExp to match field-content in RFC 7230 sec 3.2\n *\n * field-content = field-vchar [ 1*( SP / HTAB ) field-vchar ]\n * field-vchar   = VCHAR / obs-text\n * obs-text      = %x80-FF\n */\n\nvar fieldContentRegExp = /^[\\u0009\\u0020-\\u007e\\u0080-\\u00ff]+$/;\n\n/**\n * Parse a cookie header.\n *\n * Parse the given cookie header string into an object\n * The object has the various cookies as keys(names) => values\n *\n * @param {string} str\n * @param {object} [options]\n * @return {object}\n * @public\n */\n\nfunction parse(str, options) {\n  if (typeof str !== 'string') {\n    throw new TypeError('argument str must be a string');\n  }\n\n  var obj = {}\n  var opt = options || {};\n  var pairs = str.split(';')\n  var dec = opt.decode || decode;\n\n  for (var i = 0; i < pairs.length; i++) {\n    var pair = pairs[i];\n    var index = pair.indexOf('=')\n\n    // skip things that don't look like key=value\n    if (index < 0) {\n      continue;\n    }\n\n    var key = pair.substring(0, index).trim()\n\n    // only assign once\n    if (undefined == obj[key]) {\n      var val = pair.substring(index + 1, pair.length).trim()\n\n      // quoted values\n      if (val[0] === '\"') {\n        val = val.slice(1, -1)\n      }\n\n      obj[key] = tryDecode(val, dec);\n    }\n  }\n\n  return obj;\n}\n\n/**\n * Serialize data into a cookie header.\n *\n * Serialize the a name value pair into a cookie string suitable for\n * http headers. An optional options object specified cookie parameters.\n *\n * serialize('foo', 'bar', { httpOnly: true })\n *   => \"foo=bar; httpOnly\"\n *\n * @param {string} name\n * @param {string} val\n * @param {object} [options]\n * @return {string}\n * @public\n */\n\nfunction serialize(name, val, options) {\n  var opt = options || {};\n  var enc = opt.encode || encode;\n\n  if (typeof enc !== 'function') {\n    throw new TypeError('option encode is invalid');\n  }\n\n  if (!fieldContentRegExp.test(name)) {\n    throw new TypeError('argument name is invalid');\n  }\n\n  var value = enc(val);\n\n  if (value && !fieldContentRegExp.test(value)) {\n    throw new TypeError('argument val is invalid');\n  }\n\n  var str = name + '=' + value;\n\n  if (null != opt.maxAge) {\n    var maxAge = opt.maxAge - 0;\n\n    if (isNaN(maxAge) || !isFinite(maxAge)) {\n      throw new TypeError('option maxAge is invalid')\n    }\n\n    str += '; Max-Age=' + Math.floor(maxAge);\n  }\n\n  if (opt.domain) {\n    if (!fieldContentRegExp.test(opt.domain)) {\n      throw new TypeError('option domain is invalid');\n    }\n\n    str += '; Domain=' + opt.domain;\n  }\n\n  if (opt.path) {\n    if (!fieldContentRegExp.test(opt.path)) {\n      throw new TypeError('option path is invalid');\n    }\n\n    str += '; Path=' + opt.path;\n  }\n\n  if (opt.expires) {\n    if (typeof opt.expires.toUTCString !== 'function') {\n      throw new TypeError('option expires is invalid');\n    }\n\n    str += '; Expires=' + opt.expires.toUTCString();\n  }\n\n  if (opt.httpOnly) {\n    str += '; HttpOnly';\n  }\n\n  if (opt.secure) {\n    str += '; Secure';\n  }\n\n  if (opt.sameSite) {\n    var sameSite = typeof opt.sameSite === 'string'\n      ? opt.sameSite.toLowerCase() : opt.sameSite;\n\n    switch (sameSite) {\n      case true:\n        str += '; SameSite=Strict';\n        break;\n      case 'lax':\n        str += '; SameSite=Lax';\n        break;\n      case 'strict':\n        str += '; SameSite=Strict';\n        break;\n      case 'none':\n        str += '; SameSite=None';\n        break;\n      default:\n        throw new TypeError('option sameSite is invalid');\n    }\n  }\n\n  return str;\n}\n\n/**\n * Try decoding a string using a decoding function.\n *\n * @param {string} str\n * @param {function} decode\n * @private\n */\n\nfunction tryDecode(str, decode) {\n  try {\n    return decode(str);\n  } catch (e) {\n    return str;\n  }\n}\n", "/**\n * @remix-run/server-runtime v1.3.3\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\nimport { parse, serialize } from 'cookie';\n\n/**\n * Creates a logical container for managing a browser cookie from the server.\n *\n * @see https://remix.run/api/remix#createcookie\n */\nconst createCookieFactory = ({\n  sign,\n  unsign\n}) => (name, cookieOptions = {}) => {\n  let {\n    secrets,\n    ...options\n  } = {\n    secrets: [],\n    path: \"/\",\n    ...cookieOptions\n  };\n  return {\n    get name() {\n      return name;\n    },\n\n    get isSigned() {\n      return secrets.length > 0;\n    },\n\n    get expires() {\n      // Max-Age takes precedence over Expires\n      return typeof options.maxAge !== \"undefined\" ? new Date(Date.now() + options.maxAge * 1000) : options.expires;\n    },\n\n    async parse(cookieHeader, parseOptions) {\n      if (!cookieHeader) return null;\n      let cookies = parse(cookieHeader, { ...options,\n        ...parseOptions\n      });\n      return name in cookies ? cookies[name] === \"\" ? \"\" : await decodeCookieValue(unsign, cookies[name], secrets) : null;\n    },\n\n    async serialize(value, serializeOptions) {\n      return serialize(name, value === \"\" ? \"\" : await encodeCookieValue(sign, value, secrets), { ...options,\n        ...serializeOptions\n      });\n    }\n\n  };\n};\n\n/**\n * Returns true if an object is a Remix cookie container.\n *\n * @see https://remix.run/api/remix#iscookie\n */\nconst isCookie = object => {\n  return object != null && typeof object.name === \"string\" && typeof object.isSigned === \"boolean\" && typeof object.parse === \"function\" && typeof object.serialize === \"function\";\n};\n\nasync function encodeCookieValue(sign, value, secrets) {\n  let encoded = encodeData(value);\n\n  if (secrets.length > 0) {\n    encoded = await sign(encoded, secrets[0]);\n  }\n\n  return encoded;\n}\n\nasync function decodeCookieValue(unsign, value, secrets) {\n  if (secrets.length > 0) {\n    for (let secret of secrets) {\n      let unsignedValue = await unsign(value, secret);\n\n      if (unsignedValue !== false) {\n        return decodeData(unsignedValue);\n      }\n    }\n\n    return null;\n  }\n\n  return decodeData(value);\n}\n\nfunction encodeData(value) {\n  return btoa(JSON.stringify(value));\n}\n\nfunction decodeData(value) {\n  try {\n    return JSON.parse(atob(value));\n  } catch (error) {\n    return {};\n  }\n}\n\nexport { createCookieFactory, isCookie };\n", "/**\n * @remix-run/server-runtime v1.3.3\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\n/**\n * This is a shortcut for creating `application/json` responses. Converts `data`\n * to JSON and sets the `Content-Type` header.\n *\n * @see https://remix.run/api/remix#json\n */\nconst json = (data, init = {}) => {\n  let responseInit = init;\n\n  if (typeof init === \"number\") {\n    responseInit = {\n      status: init\n    };\n  }\n\n  let headers = new Headers(responseInit.headers);\n\n  if (!headers.has(\"Content-Type\")) {\n    headers.set(\"Content-Type\", \"application/json; charset=utf-8\");\n  }\n\n  return new Response(JSON.stringify(data), { ...responseInit,\n    headers\n  });\n};\n\n/**\n * A redirect response. Sets the status code and the `Location` header.\n * Defaults to \"302 Found\".\n *\n * @see https://remix.run/api/remix#redirect\n */\nconst redirect = (url, init = 302) => {\n  let responseInit = init;\n\n  if (typeof responseInit === \"number\") {\n    responseInit = {\n      status: responseInit\n    };\n  } else if (typeof responseInit.status === \"undefined\") {\n    responseInit.status = 302;\n  }\n\n  let headers = new Headers(responseInit.headers);\n  headers.set(\"Location\", url);\n  return new Response(null, { ...responseInit,\n    headers\n  });\n};\nfunction isResponse(value) {\n  return value != null && typeof value.status === \"number\" && typeof value.statusText === \"string\" && typeof value.headers === \"object\" && typeof value.body !== \"undefined\";\n}\nconst redirectStatusCodes = new Set([301, 302, 303, 307, 308]);\nfunction isRedirectResponse(response) {\n  return redirectStatusCodes.has(response.status);\n}\nfunction isCatchResponse(response) {\n  return response.headers.get(\"X-Remix-Catch\") != null;\n}\n\nexport { isCatchResponse, isRedirectResponse, isResponse, json, redirect };\n", "/**\n * @remix-run/server-runtime v1.3.3\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\nimport { isResponse, isRedirectResponse, json } from './responses.js';\n\n/**\n * An object of arbitrary for route loaders and actions provided by the\n * server's `getLoadContext()` function.\n */\n\nasync function callRouteAction({\n  loadContext,\n  match,\n  request\n}) {\n  let action = match.route.module.action;\n\n  if (!action) {\n    let response = new Response(null, {\n      status: 405\n    });\n    response.headers.set(\"X-Remix-Catch\", \"yes\");\n    return response;\n  }\n\n  let result;\n\n  try {\n    result = await action({\n      request: stripDataParam(stripIndexParam(request)),\n      context: loadContext,\n      params: match.params\n    });\n  } catch (error) {\n    if (!isResponse(error)) {\n      throw error;\n    }\n\n    if (!isRedirectResponse(error)) {\n      error.headers.set(\"X-Remix-Catch\", \"yes\");\n    }\n\n    result = error;\n  }\n\n  if (result === undefined) {\n    throw new Error(`You defined an action for route \"${match.route.id}\" but didn't return ` + `anything from your \\`action\\` function. Please return a value or \\`null\\`.`);\n  }\n\n  return isResponse(result) ? result : json(result);\n}\nasync function callRouteLoader({\n  loadContext,\n  match,\n  request\n}) {\n  let loader = match.route.module.loader;\n\n  if (!loader) {\n    throw new Error(`You made a ${request.method} request to ${request.url} but did not provide ` + `a \\`loader\\` for route \"${match.route.id}\", so there is no way to handle the ` + `request.`);\n  }\n\n  let result;\n\n  try {\n    result = await loader({\n      request: stripDataParam(stripIndexParam(request.clone())),\n      context: loadContext,\n      params: match.params\n    });\n  } catch (error) {\n    if (!isResponse(error)) {\n      throw error;\n    }\n\n    if (!isRedirectResponse(error)) {\n      error.headers.set(\"X-Remix-Catch\", \"yes\");\n    }\n\n    result = error;\n  }\n\n  if (result === undefined) {\n    throw new Error(`You defined a loader for route \"${match.route.id}\" but didn't return ` + `anything from your \\`loader\\` function. Please return a value or \\`null\\`.`);\n  }\n\n  return isResponse(result) ? result : json(result);\n}\n\nfunction stripIndexParam(request) {\n  let url = new URL(request.url);\n  let indexValues = url.searchParams.getAll(\"index\");\n  url.searchParams.delete(\"index\");\n  let indexValuesToKeep = [];\n\n  for (let indexValue of indexValues) {\n    if (indexValue) {\n      indexValuesToKeep.push(indexValue);\n    }\n  }\n\n  for (let toKeep of indexValuesToKeep) {\n    url.searchParams.append(\"index\", toKeep);\n  }\n\n  return new Request(url.href, request);\n}\n\nfunction stripDataParam(request) {\n  let url = new URL(request.url);\n  url.searchParams.delete(\"_data\");\n  return new Request(url.href, request);\n}\n\nfunction extractData(response) {\n  let contentType = response.headers.get(\"Content-Type\");\n\n  if (contentType && /\\bapplication\\/json\\b/.test(contentType)) {\n    return response.json();\n  } // What other data types do we need to handle here? What other kinds of\n  // responses are people going to be returning from their loaders?\n  // - application/x-www-form-urlencoded ?\n  // - multipart/form-data ?\n  // - binary (audio/video) ?\n\n\n  return response.text();\n}\n\nexport { callRouteAction, callRouteLoader, extractData };\n", "/**\n * @remix-run/server-runtime v1.3.3\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\nfunction createEntryMatches(matches, routes) {\n  return matches.map(match => ({\n    params: match.params,\n    pathname: match.pathname,\n    route: routes[match.route.id]\n  }));\n}\nfunction createEntryRouteModules(manifest) {\n  return Object.keys(manifest).reduce((memo, routeId) => {\n    memo[routeId] = manifest[routeId].module;\n    return memo;\n  }, {});\n}\n\nexport { createEntryMatches, createEntryRouteModules };\n", "/**\n * @remix-run/server-runtime v1.3.3\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\n/**\n * This thing probably warrants some explanation.\n *\n * The whole point here is to emulate componentDidCatch for server rendering and\n * data loading. It can get tricky. React can do this on component boundaries\n * but doesn't support it for server rendering or data loading. We know enough\n * with nested routes to be able to emulate the behavior (because we know them\n * statically before rendering.)\n *\n * Each route can export an `ErrorBoundary`.\n *\n * - When rendering throws an error, the nearest error boundary will render\n *   (normal react componentDidCatch). This will be the route's own boundary, but\n *   if none is provided, it will bubble up to the parents.\n * - When data loading throws an error, the nearest error boundary will render\n * - When performing an action, the nearest error boundary for the action's\n *   route tree will render (no redirect happens)\n *\n * During normal react rendering, we do nothing special, just normal\n * componentDidCatch.\n *\n * For server rendering, we mutate `renderBoundaryRouteId` to know the last\n * layout that has an error boundary that tried to render. This emulates which\n * layout would catch a thrown error. If the rendering fails, we catch the error\n * on the server, and go again a second time with the emulator holding on to the\n * information it needs to render the same error boundary as a dynamically\n * thrown render error.\n *\n * When data loading, server or client side, we use the emulator to likewise\n * hang on to the error and re-render at the appropriate layout (where a thrown\n * error would have been caught by cDC).\n *\n * When actions throw, it all works the same. There's an edge case to be aware\n * of though. Actions normally are required to redirect, but in the case of\n * errors, we render the action's route with the emulator holding on to the\n * error. If during this render a parent route/loader throws we ignore that new\n * error and render the action's original error as deeply as possible. In other\n * words, we simply ignore the new error and use the action's error in place\n * because it came first, and that just wouldn't be fair to let errors cut in\n * line.\n */\nasync function serializeError(error) {\n  return {\n    message: error.message,\n    stack: error.stack\n  };\n}\n\nexport { serializeError };\n", "\"use strict\";\n\nvar defaultParseOptions = {\n  decodeValues: true,\n  map: false,\n  silent: false,\n};\n\nfunction isNonEmptyString(str) {\n  return typeof str === \"string\" && !!str.trim();\n}\n\nfunction parseString(setCookieValue, options) {\n  var parts = setCookieValue.split(\";\").filter(isNonEmptyString);\n  var nameValue = parts.shift().split(\"=\");\n  var name = nameValue.shift();\n  var value = nameValue.join(\"=\"); // everything after the first =, joined by a \"=\" if there was more than one part\n\n  options = options\n    ? Object.assign({}, defaultParseOptions, options)\n    : defaultParseOptions;\n\n  try {\n    value = options.decodeValues ? decodeURIComponent(value) : value; // decode cookie value\n  } catch (e) {\n    console.error(\n      \"set-cookie-parser encountered an error while decoding a cookie with value '\" +\n        value +\n        \"'. Set options.decodeValues to false to disable this feature.\",\n      e\n    );\n  }\n\n  var cookie = {\n    name: name, // grab everything before the first =\n    value: value,\n  };\n\n  parts.forEach(function (part) {\n    var sides = part.split(\"=\");\n    var key = sides.shift().trimLeft().toLowerCase();\n    var value = sides.join(\"=\");\n    if (key === \"expires\") {\n      cookie.expires = new Date(value);\n    } else if (key === \"max-age\") {\n      cookie.maxAge = parseInt(value, 10);\n    } else if (key === \"secure\") {\n      cookie.secure = true;\n    } else if (key === \"httponly\") {\n      cookie.httpOnly = true;\n    } else if (key === \"samesite\") {\n      cookie.sameSite = value;\n    } else {\n      cookie[key] = value;\n    }\n  });\n\n  return cookie;\n}\n\nfunction parse(input, options) {\n  options = options\n    ? Object.assign({}, defaultParseOptions, options)\n    : defaultParseOptions;\n\n  if (!input) {\n    if (!options.map) {\n      return [];\n    } else {\n      return {};\n    }\n  }\n\n  if (input.headers && input.headers[\"set-cookie\"]) {\n    // fast-path for node.js (which automatically normalizes header names to lower-case\n    input = input.headers[\"set-cookie\"];\n  } else if (input.headers) {\n    // slow-path for other environments - see #25\n    var sch =\n      input.headers[\n        Object.keys(input.headers).find(function (key) {\n          return key.toLowerCase() === \"set-cookie\";\n        })\n      ];\n    // warn if called on a request-like object with a cookie header rather than a set-cookie header - see #34, 36\n    if (!sch && input.headers.cookie && !options.silent) {\n      console.warn(\n        \"Warning: set-cookie-parser appears to have been called on a request object. It is designed to parse Set-Cookie headers from responses, not Cookie headers from requests. Set the option {silent: true} to suppress this warning.\"\n      );\n    }\n    input = sch;\n  }\n  if (!Array.isArray(input)) {\n    input = [input];\n  }\n\n  options = options\n    ? Object.assign({}, defaultParseOptions, options)\n    : defaultParseOptions;\n\n  if (!options.map) {\n    return input.filter(isNonEmptyString).map(function (str) {\n      return parseString(str, options);\n    });\n  } else {\n    var cookies = {};\n    return input.filter(isNonEmptyString).reduce(function (cookies, str) {\n      var cookie = parseString(str, options);\n      cookies[cookie.name] = cookie;\n      return cookies;\n    }, cookies);\n  }\n}\n\n/*\n  Set-Cookie header field-values are sometimes comma joined in one string. This splits them without choking on commas\n  that are within a single set-cookie field-value, such as in the Expires portion.\n\n  This is uncommon, but explicitly allowed - see https://tools.ietf.org/html/rfc2616#section-4.2\n  Node.js does this for every header *except* set-cookie - see https://github.com/nodejs/node/blob/d5e363b77ebaf1caf67cd7528224b651c86815c1/lib/_http_incoming.js#L128\n  React Native's fetch does this for *every* header, including set-cookie.\n\n  Based on: https://github.com/google/j2objc/commit/16820fdbc8f76ca0c33472810ce0cb03d20efe25\n  Credits to: https://github.com/tomball for original and https://github.com/chrusart for JavaScript implementation\n*/\nfunction splitCookiesString(cookiesString) {\n  if (Array.isArray(cookiesString)) {\n    return cookiesString;\n  }\n  if (typeof cookiesString !== \"string\") {\n    return [];\n  }\n\n  var cookiesStrings = [];\n  var pos = 0;\n  var start;\n  var ch;\n  var lastComma;\n  var nextStart;\n  var cookiesSeparatorFound;\n\n  function skipWhitespace() {\n    while (pos < cookiesString.length && /\\s/.test(cookiesString.charAt(pos))) {\n      pos += 1;\n    }\n    return pos < cookiesString.length;\n  }\n\n  function notSpecialChar() {\n    ch = cookiesString.charAt(pos);\n\n    return ch !== \"=\" && ch !== \";\" && ch !== \",\";\n  }\n\n  while (pos < cookiesString.length) {\n    start = pos;\n    cookiesSeparatorFound = false;\n\n    while (skipWhitespace()) {\n      ch = cookiesString.charAt(pos);\n      if (ch === \",\") {\n        // ',' is a cookie separator if we have later first '=', not ';' or ','\n        lastComma = pos;\n        pos += 1;\n\n        skipWhitespace();\n        nextStart = pos;\n\n        while (pos < cookiesString.length && notSpecialChar()) {\n          pos += 1;\n        }\n\n        // currently special character\n        if (pos < cookiesString.length && cookiesString.charAt(pos) === \"=\") {\n          // we found cookies separator\n          cookiesSeparatorFound = true;\n          // pos is inside the next cookie, so back up and return it.\n          pos = nextStart;\n          cookiesStrings.push(cookiesString.substring(start, lastComma));\n          start = pos;\n        } else {\n          // in param ',' or param separator ';',\n          // we continue from that comma\n          pos = lastComma + 1;\n        }\n      } else {\n        pos += 1;\n      }\n    }\n\n    if (!cookiesSeparatorFound || pos >= cookiesString.length) {\n      cookiesStrings.push(cookiesString.substring(start, cookiesString.length));\n    }\n  }\n\n  return cookiesStrings;\n}\n\nmodule.exports = parse;\nmodule.exports.parse = parse;\nmodule.exports.parseString = parseString;\nmodule.exports.splitCookiesString = splitCookiesString;\n", "/**\n * @remix-run/server-runtime v1.3.3\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\nimport { splitCookiesString } from 'set-cookie-parser';\n\nfunction getDocumentHeaders(build, matches, routeLoaderResponses, actionResponse) {\n  return matches.reduce((parentHeaders, match, index) => {\n    let routeModule = build.routes[match.route.id].module;\n    let routeLoaderResponse = routeLoaderResponses[match.route.id];\n    let loaderHeaders = routeLoaderResponse ? routeLoaderResponse.headers : new Headers();\n    let actionHeaders = actionResponse ? actionResponse.headers : new Headers();\n    let headers = new Headers(routeModule.headers ? typeof routeModule.headers === \"function\" ? routeModule.headers({\n      loaderHeaders,\n      parentHeaders,\n      actionHeaders\n    }) : routeModule.headers : undefined); // Automatically preserve Set-Cookie headers that were set either by the\n    // loader or by a parent route.\n\n    prependCookies(actionHeaders, headers);\n    prependCookies(loaderHeaders, headers);\n    prependCookies(parentHeaders, headers);\n    return headers;\n  }, new Headers());\n}\n\nfunction prependCookies(parentHeaders, childHeaders) {\n  let parentSetCookieString = parentHeaders.get(\"Set-Cookie\");\n\n  if (parentSetCookieString) {\n    let cookies = splitCookiesString(parentSetCookieString);\n    cookies.forEach(cookie => {\n      childHeaders.append(\"Set-Cookie\", cookie);\n    });\n  }\n}\n\nexport { getDocumentHeaders };\n", "/**\n * @remix-run/server-runtime v1.3.3\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\n/**\n * The mode to use when running the server.\n */\nlet ServerMode;\n\n(function (ServerMode) {\n  ServerMode[\"Development\"] = \"development\";\n  ServerMode[\"Production\"] = \"production\";\n  ServerMode[\"Test\"] = \"test\";\n})(ServerMode || (ServerMode = {}));\n\nfunction isServerMode(value) {\n  return value === ServerMode.Development || value === ServerMode.Production || value === ServerMode.Test;\n}\n\nexport { ServerMode, isServerMode };\n", "/**\n * @remix-run/server-runtime v1.3.3\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\nimport { matchRoutes } from 'react-router-dom';\n\n// TODO: export/import from react-router-dom\nfunction matchServerRoutes(routes, pathname) {\n  let matches = matchRoutes(routes, pathname);\n  if (!matches) return null;\n  return matches.map(match => ({\n    params: match.params,\n    pathname: match.pathname,\n    route: match.route\n  }));\n}\n\nexport { matchServerRoutes };\n", "/**\n * @remix-run/server-runtime v1.3.3\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\n// NOTE: make sure to change the Route in remix-react if you change this\n// NOTE: make sure to change the EntryRoute in remix-react if you change this\nfunction createRoutes(manifest, parentId) {\n  return Object.keys(manifest).filter(key => manifest[key].parentId === parentId).map(id => ({ ...manifest[id],\n    children: createRoutes(manifest, id)\n  }));\n}\n\nexport { createRoutes };\n", "'use strict';\n\nconst object = {};\nconst hasOwnProperty = object.hasOwnProperty;\nconst forOwn = (object, callback) => {\n\tfor (const key in object) {\n\t\tif (hasOwnProperty.call(object, key)) {\n\t\t\tcallback(key, object[key]);\n\t\t}\n\t}\n};\n\nconst extend = (destination, source) => {\n\tif (!source) {\n\t\treturn destination;\n\t}\n\tforOwn(source, (key, value) => {\n\t\tdestination[key] = value;\n\t});\n\treturn destination;\n};\n\nconst forEach = (array, callback) => {\n\tconst length = array.length;\n\tlet index = -1;\n\twhile (++index < length) {\n\t\tcallback(array[index]);\n\t}\n};\n\nconst fourHexEscape = (hex) => {\n\treturn '\\\\u' + ('0000' + hex).slice(-4);\n}\n\nconst hexadecimal = (code, lowercase) => {\n\tlet hexadecimal = code.toString(16);\n\tif (lowercase) return hexadecimal;\n\treturn hexadecimal.toUpperCase();\n};\n\nconst toString = object.toString;\nconst isArray = Array.isArray;\nconst isBuffer = (value) => {\n\treturn typeof Buffer === 'function' && Buffer.isBuffer(value);\n};\nconst isObject = (value) => {\n\t// This is a very simple check, but it\u2019s good enough for what we need.\n\treturn toString.call(value) == '[object Object]';\n};\nconst isString = (value) => {\n\treturn typeof value == 'string' ||\n\t\ttoString.call(value) == '[object String]';\n};\nconst isNumber = (value) => {\n\treturn typeof value == 'number' ||\n\t\ttoString.call(value) == '[object Number]';\n};\nconst isFunction = (value) => {\n\treturn typeof value == 'function';\n};\nconst isMap = (value) => {\n\treturn toString.call(value) == '[object Map]';\n};\nconst isSet = (value) => {\n\treturn toString.call(value) == '[object Set]';\n};\n\n/*--------------------------------------------------------------------------*/\n\n// https://mathiasbynens.be/notes/javascript-escapes#single\nconst singleEscapes = {\n\t'\\\\': '\\\\\\\\',\n\t'\\b': '\\\\b',\n\t'\\f': '\\\\f',\n\t'\\n': '\\\\n',\n\t'\\r': '\\\\r',\n\t'\\t': '\\\\t'\n\t// `\\v` is omitted intentionally, because in IE < 9, '\\v' == 'v'.\n\t// '\\v': '\\\\x0B'\n};\nconst regexSingleEscape = /[\\\\\\b\\f\\n\\r\\t]/;\n\nconst regexDigit = /[0-9]/;\nconst regexWhitespace = /[\\xA0\\u1680\\u2000-\\u200A\\u2028\\u2029\\u202F\\u205F\\u3000]/;\n\nconst escapeEverythingRegex = /([\\uD800-\\uDBFF][\\uDC00-\\uDFFF])|([\\uD800-\\uDFFF])|(['\"`])|[^]/g;\nconst escapeNonAsciiRegex = /([\\uD800-\\uDBFF][\\uDC00-\\uDFFF])|([\\uD800-\\uDFFF])|(['\"`])|[^ !#-&\\(-\\[\\]-_a-~]/g;\n\nconst jsesc = (argument, options) => {\n\tconst increaseIndentation = () => {\n\t\toldIndent = indent;\n\t\t++options.indentLevel;\n\t\tindent = options.indent.repeat(options.indentLevel)\n\t};\n\t// Handle options\n\tconst defaults = {\n\t\t'escapeEverything': false,\n\t\t'minimal': false,\n\t\t'isScriptContext': false,\n\t\t'quotes': 'single',\n\t\t'wrap': false,\n\t\t'es6': false,\n\t\t'json': false,\n\t\t'compact': true,\n\t\t'lowercaseHex': false,\n\t\t'numbers': 'decimal',\n\t\t'indent': '\\t',\n\t\t'indentLevel': 0,\n\t\t'__inline1__': false,\n\t\t'__inline2__': false\n\t};\n\tconst json = options && options.json;\n\tif (json) {\n\t\tdefaults.quotes = 'double';\n\t\tdefaults.wrap = true;\n\t}\n\toptions = extend(defaults, options);\n\tif (\n\t\toptions.quotes != 'single' &&\n\t\toptions.quotes != 'double' &&\n\t\toptions.quotes != 'backtick'\n\t) {\n\t\toptions.quotes = 'single';\n\t}\n\tconst quote = options.quotes == 'double' ?\n\t\t'\"' :\n\t\t(options.quotes == 'backtick' ?\n\t\t\t'`' :\n\t\t\t'\\''\n\t\t);\n\tconst compact = options.compact;\n\tconst lowercaseHex = options.lowercaseHex;\n\tlet indent = options.indent.repeat(options.indentLevel);\n\tlet oldIndent = '';\n\tconst inline1 = options.__inline1__;\n\tconst inline2 = options.__inline2__;\n\tconst newLine = compact ? '' : '\\n';\n\tlet result;\n\tlet isEmpty = true;\n\tconst useBinNumbers = options.numbers == 'binary';\n\tconst useOctNumbers = options.numbers == 'octal';\n\tconst useDecNumbers = options.numbers == 'decimal';\n\tconst useHexNumbers = options.numbers == 'hexadecimal';\n\n\tif (json && argument && isFunction(argument.toJSON)) {\n\t\targument = argument.toJSON();\n\t}\n\n\tif (!isString(argument)) {\n\t\tif (isMap(argument)) {\n\t\t\tif (argument.size == 0) {\n\t\t\t\treturn 'new Map()';\n\t\t\t}\n\t\t\tif (!compact) {\n\t\t\t\toptions.__inline1__ = true;\n\t\t\t\toptions.__inline2__ = false;\n\t\t\t}\n\t\t\treturn 'new Map(' + jsesc(Array.from(argument), options) + ')';\n\t\t}\n\t\tif (isSet(argument)) {\n\t\t\tif (argument.size == 0) {\n\t\t\t\treturn 'new Set()';\n\t\t\t}\n\t\t\treturn 'new Set(' + jsesc(Array.from(argument), options) + ')';\n\t\t}\n\t\tif (isBuffer(argument)) {\n\t\t\tif (argument.length == 0) {\n\t\t\t\treturn 'Buffer.from([])';\n\t\t\t}\n\t\t\treturn 'Buffer.from(' + jsesc(Array.from(argument), options) + ')';\n\t\t}\n\t\tif (isArray(argument)) {\n\t\t\tresult = [];\n\t\t\toptions.wrap = true;\n\t\t\tif (inline1) {\n\t\t\t\toptions.__inline1__ = false;\n\t\t\t\toptions.__inline2__ = true;\n\t\t\t}\n\t\t\tif (!inline2) {\n\t\t\t\tincreaseIndentation();\n\t\t\t}\n\t\t\tforEach(argument, (value) => {\n\t\t\t\tisEmpty = false;\n\t\t\t\tif (inline2) {\n\t\t\t\t\toptions.__inline2__ = false;\n\t\t\t\t}\n\t\t\t\tresult.push(\n\t\t\t\t\t(compact || inline2 ? '' : indent) +\n\t\t\t\t\tjsesc(value, options)\n\t\t\t\t);\n\t\t\t});\n\t\t\tif (isEmpty) {\n\t\t\t\treturn '[]';\n\t\t\t}\n\t\t\tif (inline2) {\n\t\t\t\treturn '[' + result.join(', ') + ']';\n\t\t\t}\n\t\t\treturn '[' + newLine + result.join(',' + newLine) + newLine +\n\t\t\t\t(compact ? '' : oldIndent) + ']';\n\t\t} else if (isNumber(argument)) {\n\t\t\tif (json) {\n\t\t\t\t// Some number values (e.g. `Infinity`) cannot be represented in JSON.\n\t\t\t\treturn JSON.stringify(argument);\n\t\t\t}\n\t\t\tif (useDecNumbers) {\n\t\t\t\treturn String(argument);\n\t\t\t}\n\t\t\tif (useHexNumbers) {\n\t\t\t\tlet hexadecimal = argument.toString(16);\n\t\t\t\tif (!lowercaseHex) {\n\t\t\t\t\thexadecimal = hexadecimal.toUpperCase();\n\t\t\t\t}\n\t\t\t\treturn '0x' + hexadecimal;\n\t\t\t}\n\t\t\tif (useBinNumbers) {\n\t\t\t\treturn '0b' + argument.toString(2);\n\t\t\t}\n\t\t\tif (useOctNumbers) {\n\t\t\t\treturn '0o' + argument.toString(8);\n\t\t\t}\n\t\t} else if (!isObject(argument)) {\n\t\t\tif (json) {\n\t\t\t\t// For some values (e.g. `undefined`, `function` objects),\n\t\t\t\t// `JSON.stringify(value)` returns `undefined` (which isn\u2019t valid\n\t\t\t\t// JSON) instead of `'null'`.\n\t\t\t\treturn JSON.stringify(argument) || 'null';\n\t\t\t}\n\t\t\treturn String(argument);\n\t\t} else { // it\u2019s an object\n\t\t\tresult = [];\n\t\t\toptions.wrap = true;\n\t\t\tincreaseIndentation();\n\t\t\tforOwn(argument, (key, value) => {\n\t\t\t\tisEmpty = false;\n\t\t\t\tresult.push(\n\t\t\t\t\t(compact ? '' : indent) +\n\t\t\t\t\tjsesc(key, options) + ':' +\n\t\t\t\t\t(compact ? '' : ' ') +\n\t\t\t\t\tjsesc(value, options)\n\t\t\t\t);\n\t\t\t});\n\t\t\tif (isEmpty) {\n\t\t\t\treturn '{}';\n\t\t\t}\n\t\t\treturn '{' + newLine + result.join(',' + newLine) + newLine +\n\t\t\t\t(compact ? '' : oldIndent) + '}';\n\t\t}\n\t}\n\n\tconst regex = options.escapeEverything ? escapeEverythingRegex : escapeNonAsciiRegex;\n\tresult = argument.replace(regex, (char, pair, lone, quoteChar, index, string) => {\n\t\tif (pair) {\n\t\t\tif (options.minimal) return pair;\n\t\t\tconst first = pair.charCodeAt(0);\n\t\t\tconst second = pair.charCodeAt(1);\n\t\t\tif (options.es6) {\n\t\t\t\t// https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n\t\t\t\tconst codePoint = (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;\n\t\t\t\tconst hex = hexadecimal(codePoint, lowercaseHex);\n\t\t\t\treturn '\\\\u{' + hex + '}';\n\t\t\t}\n\t\t\treturn fourHexEscape(hexadecimal(first, lowercaseHex)) + fourHexEscape(hexadecimal(second, lowercaseHex));\n\t\t}\n\n\t\tif (lone) {\n\t\t\treturn fourHexEscape(hexadecimal(lone.charCodeAt(0), lowercaseHex));\n\t\t}\n\n\t\tif (\n\t\t\tchar == '\\0' &&\n\t\t\t!json &&\n\t\t\t!regexDigit.test(string.charAt(index + 1))\n\t\t) {\n\t\t\treturn '\\\\0';\n\t\t}\n\n\t\tif (quoteChar) {\n\t\t\tif (quoteChar == quote || options.escapeEverything) {\n\t\t\t\treturn '\\\\' + quoteChar;\n\t\t\t}\n\t\t\treturn quoteChar;\n\t\t}\n\n\t\tif (regexSingleEscape.test(char)) {\n\t\t\t// no need for a `hasOwnProperty` check here\n\t\t\treturn singleEscapes[char];\n\t\t}\n\n\t\tif (options.minimal && !regexWhitespace.test(char)) {\n\t\t\treturn char;\n\t\t}\n\n\t\tconst hex = hexadecimal(char.charCodeAt(0), lowercaseHex);\n\t\tif (json || hex.length > 2) {\n\t\t\treturn fourHexEscape(hex);\n\t\t}\n\n\t\treturn '\\\\x' + ('00' + hex).slice(-2);\n\t});\n\n\tif (quote == '`') {\n\t\tresult = result.replace(/\\$\\{/g, '\\\\${');\n\t}\n\tif (options.isScriptContext) {\n\t\t// https://mathiasbynens.be/notes/etago\n\t\tresult = result\n\t\t\t.replace(/<\\/(script|style)/gi, '<\\\\/$1')\n\t\t\t.replace(/<!--/g, json ? '\\\\u003C!--' : '\\\\x3C!--');\n\t}\n\tif (options.wrap) {\n\t\tresult = quote + result + quote;\n\t}\n\treturn result;\n};\n\njsesc.version = '3.0.2';\n\nmodule.exports = jsesc;\n", "/**\n * @remix-run/server-runtime v1.3.3\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\nimport jsesc from 'jsesc';\n\nfunction createServerHandoffString(serverHandoff) {\n  // Use jsesc to escape data returned from the loaders. This string is\n  // inserted directly into the HTML in the `<Scripts>` element.\n  return jsesc(serverHandoff, {\n    isScriptContext: true\n  });\n}\n\nexport { createServerHandoffString };\n", "/**\n * @remix-run/server-runtime v1.3.3\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\nimport { callRouteAction, callRouteLoader, extractData } from './data.js';\nimport { createEntryRouteModules, createEntryMatches } from './entry.js';\nimport { serializeError } from './errors.js';\nimport { getDocumentHeaders } from './headers.js';\nimport { isServerMode, ServerMode } from './mode.js';\nimport { matchServerRoutes } from './routeMatching.js';\nimport { createRoutes } from './routes.js';\nimport { isRedirectResponse, isCatchResponse, json } from './responses.js';\nimport { createServerHandoffString } from './serverHandoff.js';\n\nconst createRequestHandler = (build, mode) => {\n  let routes = createRoutes(build.routes);\n  let serverMode = isServerMode(mode) ? mode : ServerMode.Production;\n  return async function requestHandler(request, loadContext) {\n    let url = new URL(request.url);\n    let matches = matchServerRoutes(routes, url.pathname);\n    let response;\n\n    if (url.searchParams.has(\"_data\")) {\n      response = await handleDataRequest({\n        request,\n        loadContext,\n        matches: matches,\n        handleDataRequest: build.entry.module.handleDataRequest,\n        serverMode\n      });\n    } else if (matches && !matches[matches.length - 1].route.module.default) {\n      response = await handleResourceRequest({\n        request,\n        loadContext,\n        matches,\n        serverMode\n      });\n    } else {\n      response = await handleDocumentRequest({\n        build,\n        loadContext,\n        matches,\n        request,\n        routes,\n        serverMode\n      });\n    }\n\n    if (request.method.toLowerCase() === \"head\") {\n      return new Response(null, {\n        headers: response.headers,\n        status: response.status,\n        statusText: response.statusText\n      });\n    }\n\n    return response;\n  };\n};\n\nasync function handleDataRequest({\n  handleDataRequest,\n  loadContext,\n  matches,\n  request,\n  serverMode\n}) {\n  if (!isValidRequestMethod(request)) {\n    return errorBoundaryError(new Error(`Invalid request method \"${request.method}\"`), 405);\n  }\n\n  let url = new URL(request.url);\n\n  if (!matches) {\n    return errorBoundaryError(new Error(`No route matches URL \"${url.pathname}\"`), 404);\n  }\n\n  let response;\n  let match;\n\n  try {\n    if (isActionRequest(request)) {\n      match = getRequestMatch(url, matches);\n      response = await callRouteAction({\n        loadContext,\n        match,\n        request: request\n      });\n    } else {\n      let routeId = url.searchParams.get(\"_data\");\n\n      if (!routeId) {\n        return errorBoundaryError(new Error(`Missing route id in ?_data`), 403);\n      }\n\n      let tempMatch = matches.find(match => match.route.id === routeId);\n\n      if (!tempMatch) {\n        return errorBoundaryError(new Error(`Route \"${routeId}\" does not match URL \"${url.pathname}\"`), 403);\n      }\n\n      match = tempMatch;\n      response = await callRouteLoader({\n        loadContext,\n        match,\n        request\n      });\n    }\n\n    if (isRedirectResponse(response)) {\n      // We don't have any way to prevent a fetch request from following\n      // redirects. So we use the `X-Remix-Redirect` header to indicate the\n      // next URL, and then \"follow\" the redirect manually on the client.\n      let headers = new Headers(response.headers);\n      headers.set(\"X-Remix-Redirect\", headers.get(\"Location\"));\n      headers.delete(\"Location\");\n\n      if (response.headers.get(\"Set-Cookie\") !== null) {\n        headers.set(\"X-Remix-Revalidate\", \"yes\");\n      }\n\n      return new Response(null, {\n        status: 204,\n        headers\n      });\n    }\n\n    if (handleDataRequest) {\n      response = await handleDataRequest(response.clone(), {\n        context: loadContext,\n        params: match.params,\n        request: request.clone()\n      });\n    }\n\n    return response;\n  } catch (error) {\n    if (serverMode !== ServerMode.Test) {\n      console.error(error);\n    }\n\n    if (serverMode === ServerMode.Development) {\n      return errorBoundaryError(error, 500);\n    }\n\n    return errorBoundaryError(new Error(\"Unexpected Server Error\"), 500);\n  }\n}\n\nasync function handleDocumentRequest({\n  build,\n  loadContext,\n  matches,\n  request,\n  routes,\n  serverMode\n}) {\n  let url = new URL(request.url);\n  let appState = {\n    trackBoundaries: true,\n    trackCatchBoundaries: true,\n    catchBoundaryRouteId: null,\n    renderBoundaryRouteId: null,\n    loaderBoundaryRouteId: null,\n    error: undefined,\n    catch: undefined\n  };\n\n  if (!isValidRequestMethod(request)) {\n    matches = null;\n    appState.trackCatchBoundaries = false;\n    appState.catch = {\n      data: null,\n      status: 405,\n      statusText: \"Method Not Allowed\"\n    };\n  } else if (!matches) {\n    appState.trackCatchBoundaries = false;\n    appState.catch = {\n      data: null,\n      status: 404,\n      statusText: \"Not Found\"\n    };\n  }\n\n  let actionStatus;\n  let actionData;\n  let actionMatch;\n  let actionResponse;\n\n  if (matches && isActionRequest(request)) {\n    actionMatch = getRequestMatch(url, matches);\n\n    try {\n      actionResponse = await callRouteAction({\n        loadContext,\n        match: actionMatch,\n        request: request\n      });\n\n      if (isRedirectResponse(actionResponse)) {\n        return actionResponse;\n      }\n\n      actionStatus = {\n        status: actionResponse.status,\n        statusText: actionResponse.statusText\n      };\n\n      if (isCatchResponse(actionResponse)) {\n        appState.catchBoundaryRouteId = getDeepestRouteIdWithBoundary(matches, \"CatchBoundary\");\n        appState.trackCatchBoundaries = false;\n        appState.catch = { ...actionStatus,\n          data: await extractData(actionResponse)\n        };\n      } else {\n        actionData = {\n          [actionMatch.route.id]: await extractData(actionResponse)\n        };\n      }\n    } catch (error) {\n      appState.loaderBoundaryRouteId = getDeepestRouteIdWithBoundary(matches, \"ErrorBoundary\");\n      appState.trackBoundaries = false;\n      appState.error = await serializeError(error);\n\n      if (serverMode !== ServerMode.Test) {\n        console.error(`There was an error running the action for route ${actionMatch.route.id}`);\n      }\n    }\n  }\n\n  let routeModules = createEntryRouteModules(build.routes);\n  let matchesToLoad = matches || [];\n\n  if (appState.catch) {\n    matchesToLoad = getMatchesUpToDeepestBoundary( // get rid of the action, we don't want to call it's loader either\n    // because we'll be rendering the catch boundary, if you can get access\n    // to the loader data in the catch boundary then how the heck is it\n    // supposed to deal with thrown responses?\n    matchesToLoad.slice(0, -1), \"CatchBoundary\");\n  } else if (appState.error) {\n    matchesToLoad = getMatchesUpToDeepestBoundary( // get rid of the action, we don't want to call it's loader either\n    // because we'll be rendering the error boundary, if you can get access\n    // to the loader data in the error boundary then how the heck is it\n    // supposed to deal with errors in the loader, too?\n    matchesToLoad.slice(0, -1), \"ErrorBoundary\");\n  }\n\n  let routeLoaderResults = await Promise.allSettled(matchesToLoad.map(match => match.route.module.loader ? callRouteLoader({\n    loadContext,\n    match,\n    request\n  }) : Promise.resolve(undefined))); // Store the state of the action. We will use this to determine later\n  // what catch or error boundary should be rendered under cases where\n  // actions don't throw but loaders do, actions throw and parent loaders\n  // also throw, etc.\n\n  let actionCatch = appState.catch;\n  let actionError = appState.error;\n  let actionCatchBoundaryRouteId = appState.catchBoundaryRouteId;\n  let actionLoaderBoundaryRouteId = appState.loaderBoundaryRouteId; // Reset the app error and catch state to propagate the loader states\n  // from the results into the app state.\n\n  appState.catch = undefined;\n  appState.error = undefined;\n  let routeLoaderResponses = {};\n  let loaderStatusCodes = [];\n  let routeData = {};\n\n  for (let index = 0; index < matchesToLoad.length; index++) {\n    let match = matchesToLoad[index];\n    let result = routeLoaderResults[index];\n    let error = result.status === \"rejected\" ? result.reason : undefined;\n    let response = result.status === \"fulfilled\" ? result.value : undefined;\n    let isRedirect = response ? isRedirectResponse(response) : false;\n    let isCatch = response ? isCatchResponse(response) : false; // If a parent loader has already caught or error'd, bail because\n    // we don't need any more child data.\n\n    if (appState.catch || appState.error) {\n      break;\n    } // If there is a response and it's a redirect, do it unless there\n    // is an action error or catch state, those action boundary states\n    // take precedence over loader sates, this means if a loader redirects\n    // after an action catches or errors we won't follow it, and instead\n    // render the boundary caused by the action.\n\n\n    if (!actionCatch && !actionError && response && isRedirect) {\n      return response;\n    } // Track the boundary ID's for the loaders\n\n\n    if (match.route.module.CatchBoundary) {\n      appState.catchBoundaryRouteId = match.route.id;\n    }\n\n    if (match.route.module.ErrorBoundary) {\n      appState.loaderBoundaryRouteId = match.route.id;\n    }\n\n    if (error) {\n      loaderStatusCodes.push(500);\n      appState.trackBoundaries = false;\n      appState.error = await serializeError(error);\n\n      if (serverMode !== ServerMode.Test) {\n        console.error(`There was an error running the data loader for route ${match.route.id}`);\n      }\n\n      break;\n    } else if (response) {\n      routeLoaderResponses[match.route.id] = response;\n      loaderStatusCodes.push(response.status);\n\n      if (isCatch) {\n        // If it's a catch response, store it in app state, and bail\n        appState.trackCatchBoundaries = false;\n        appState.catch = {\n          data: await extractData(response),\n          status: response.status,\n          statusText: response.statusText\n        };\n        break;\n      } else {\n        // Extract and store the loader data\n        routeData[match.route.id] = await extractData(response);\n      }\n    }\n  } // If there was not a loader catch or error state triggered reset the\n  // boundaries as they are probably deeper in the tree if the action\n  // initially triggered a boundary as that match would not exist in the\n  // matches to load.\n\n\n  if (!appState.catch) {\n    appState.catchBoundaryRouteId = actionCatchBoundaryRouteId;\n  }\n\n  if (!appState.error) {\n    appState.loaderBoundaryRouteId = actionLoaderBoundaryRouteId;\n  } // If there was an action error or catch, we will reset the state to the\n  // initial values, otherwise we will use whatever came out of the loaders.\n\n\n  appState.catch = actionCatch || appState.catch;\n  appState.error = actionError || appState.error;\n  let renderableMatches = getRenderableMatches(matches, appState);\n\n  if (!renderableMatches) {\n    renderableMatches = [];\n    let root = routes[0];\n\n    if (root !== null && root !== void 0 && root.module.CatchBoundary) {\n      appState.catchBoundaryRouteId = \"root\";\n      renderableMatches.push({\n        params: {},\n        pathname: \"\",\n        route: routes[0]\n      });\n    }\n  } // Handle responses with a non-200 status code. The first loader with a\n  // non-200 status code determines the status code for the whole response.\n\n\n  let notOkResponse = actionStatus && actionStatus.status !== 200 ? actionStatus.status : loaderStatusCodes.find(status => status !== 200);\n  let responseStatusCode = appState.error ? 500 : typeof notOkResponse === \"number\" ? notOkResponse : appState.catch ? appState.catch.status : 200;\n  let responseHeaders = getDocumentHeaders(build, renderableMatches, routeLoaderResponses, actionResponse);\n  let entryMatches = createEntryMatches(renderableMatches, build.assets.routes);\n  let serverHandoff = {\n    actionData,\n    appState: appState,\n    matches: entryMatches,\n    routeData\n  };\n  let entryContext = { ...serverHandoff,\n    manifest: build.assets,\n    routeModules,\n    serverHandoffString: createServerHandoffString(serverHandoff)\n  };\n  let handleDocumentRequest = build.entry.module.default;\n\n  try {\n    return await handleDocumentRequest(request.clone(), responseStatusCode, responseHeaders, entryContext);\n  } catch (error) {\n    responseStatusCode = 500; // Go again, this time with the componentDidCatch emulation. As it rendered\n    // last time we mutated `componentDidCatch.routeId` for the last rendered\n    // route, now we know where to render the error boundary (feels a little\n    // hacky but that's how hooks work). This tells the emulator to stop\n    // tracking the `routeId` as we render because we already have an error to\n    // render.\n\n    appState.trackBoundaries = false;\n    appState.error = await serializeError(error);\n    entryContext.serverHandoffString = createServerHandoffString(serverHandoff);\n\n    try {\n      return await handleDocumentRequest(request.clone(), responseStatusCode, responseHeaders, entryContext);\n    } catch (error) {\n      if (serverMode !== ServerMode.Test) {\n        console.error(error);\n      }\n\n      let message = \"Unexpected Server Error\";\n\n      if (serverMode === ServerMode.Development) {\n        message += `\\n\\n${String(error)}`;\n      } // Good grief folks, get your act together \uD83D\uDE02!\n\n\n      return new Response(message, {\n        status: 500,\n        headers: {\n          \"Content-Type\": \"text/plain\"\n        }\n      });\n    }\n  }\n}\n\nasync function handleResourceRequest({\n  loadContext,\n  matches,\n  request,\n  serverMode\n}) {\n  let match = matches.slice(-1)[0];\n\n  try {\n    if (isActionRequest(request)) {\n      return await callRouteAction({\n        match,\n        loadContext,\n        request\n      });\n    } else {\n      return await callRouteLoader({\n        match,\n        loadContext,\n        request\n      });\n    }\n  } catch (error) {\n    if (serverMode !== ServerMode.Test) {\n      console.error(error);\n    }\n\n    let message = \"Unexpected Server Error\";\n\n    if (serverMode === ServerMode.Development) {\n      message += `\\n\\n${String(error)}`;\n    } // Good grief folks, get your act together \uD83D\uDE02!\n\n\n    return new Response(message, {\n      status: 500,\n      headers: {\n        \"Content-Type\": \"text/plain\"\n      }\n    });\n  }\n}\n\nfunction isActionRequest(request) {\n  let method = request.method.toLowerCase();\n  return method === \"post\" || method === \"put\" || method === \"patch\" || method === \"delete\";\n}\n\nfunction isHeadRequest(request) {\n  return request.method.toLowerCase() === \"head\";\n}\n\nfunction isValidRequestMethod(request) {\n  return request.method.toLowerCase() === \"get\" || isHeadRequest(request) || isActionRequest(request);\n}\n\nasync function errorBoundaryError(error, status) {\n  return json(await serializeError(error), {\n    status,\n    headers: {\n      \"X-Remix-Error\": \"yes\"\n    }\n  });\n}\n\nfunction isIndexRequestUrl(url) {\n  for (let param of url.searchParams.getAll(\"index\")) {\n    // only use bare `?index` params without a value\n    // \u2705 /foo?index\n    // \u2705 /foo?index&index=123\n    // \u2705 /foo?index=123&index\n    // \u274C /foo?index=123\n    if (param === \"\") {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction getRequestMatch(url, matches) {\n  let match = matches.slice(-1)[0];\n\n  if (!isIndexRequestUrl(url) && match.route.id.endsWith(\"/index\")) {\n    return matches.slice(-2)[0];\n  }\n\n  return match;\n}\n\nfunction getDeepestRouteIdWithBoundary(matches, key) {\n  let matched = getMatchesUpToDeepestBoundary(matches, key).slice(-1)[0];\n  return matched ? matched.route.id : null;\n}\n\nfunction getMatchesUpToDeepestBoundary(matches, key) {\n  let deepestBoundaryIndex = -1;\n  matches.forEach((match, index) => {\n    if (match.route.module[key]) {\n      deepestBoundaryIndex = index;\n    }\n  });\n\n  if (deepestBoundaryIndex === -1) {\n    // no route error boundaries, don't need to call any loaders\n    return [];\n  }\n\n  return matches.slice(0, deepestBoundaryIndex + 1);\n} // This prevents `<Outlet/>` from rendering anything below where the error threw\n// TODO: maybe do this in <RemixErrorBoundary + context>\n\n\nfunction getRenderableMatches(matches, appState) {\n  if (!matches) {\n    return null;\n  } // no error, no worries\n\n\n  if (!appState.catch && !appState.error) {\n    return matches;\n  }\n\n  let lastRenderableIndex = -1;\n  matches.forEach((match, index) => {\n    let id = match.route.id;\n\n    if (appState.renderBoundaryRouteId === id || appState.loaderBoundaryRouteId === id || appState.catchBoundaryRouteId === id) {\n      lastRenderableIndex = index;\n    }\n  });\n  return matches.slice(0, lastRenderableIndex + 1);\n}\n\nexport { createRequestHandler };\n", "/**\n * @remix-run/server-runtime v1.3.3\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\nconst alreadyWarned = {};\nfunction warnOnce(condition, message) {\n  if (!condition && !alreadyWarned[message]) {\n    alreadyWarned[message] = true;\n    console.warn(message);\n  }\n}\n\nexport { warnOnce };\n", "/**\n * @remix-run/server-runtime v1.3.3\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\nimport { isCookie } from './cookies.js';\nimport { warnOnce } from './warnings.js';\n\n/**\n * An object of name/value pairs to be used in the session.\n */\n\nfunction flash(name) {\n  return `__flash_${name}__`;\n}\n\n/**\n * Creates a new Session object.\n *\n * Note: This function is typically not invoked directly by application code.\n * Instead, use a `SessionStorage` object's `getSession` method.\n *\n * @see https://remix.run/api/remix#createsession\n */\nconst createSession = (initialData = {}, id = \"\") => {\n  let map = new Map(Object.entries(initialData));\n  return {\n    get id() {\n      return id;\n    },\n\n    get data() {\n      return Object.fromEntries(map);\n    },\n\n    has(name) {\n      return map.has(name) || map.has(flash(name));\n    },\n\n    get(name) {\n      if (map.has(name)) return map.get(name);\n      let flashName = flash(name);\n\n      if (map.has(flashName)) {\n        let value = map.get(flashName);\n        map.delete(flashName);\n        return value;\n      }\n\n      return undefined;\n    },\n\n    set(name, value) {\n      map.set(name, value);\n    },\n\n    flash(name, value) {\n      map.set(flash(name), value);\n    },\n\n    unset(name) {\n      map.delete(name);\n    }\n\n  };\n};\n\n/**\n * Returns true if an object is a Remix session.\n *\n * @see https://remix.run/api/remix#issession\n */\nconst isSession = object => {\n  return object != null && typeof object.id === \"string\" && typeof object.data !== \"undefined\" && typeof object.has === \"function\" && typeof object.get === \"function\" && typeof object.set === \"function\" && typeof object.flash === \"function\" && typeof object.unset === \"function\";\n};\n/**\n * SessionStorage stores session data between HTTP requests and knows how to\n * parse and create cookies.\n *\n * A SessionStorage creates Session objects using a `Cookie` header as input.\n * Then, later it generates the `Set-Cookie` header to be used in the response.\n */\n\n/**\n * Creates a SessionStorage object using a SessionIdStorageStrategy.\n *\n * Note: This is a low-level API that should only be used if none of the\n * existing session storage options meet your requirements.\n *\n * @see https://remix.run/api/remix#createsessionstorage\n */\nconst createSessionStorageFactory = createCookie => ({\n  cookie: cookieArg,\n  createData,\n  readData,\n  updateData,\n  deleteData\n}) => {\n  let cookie = isCookie(cookieArg) ? cookieArg : createCookie((cookieArg === null || cookieArg === void 0 ? void 0 : cookieArg.name) || \"__session\", cookieArg);\n  warnOnceAboutSigningSessionCookie(cookie);\n  return {\n    async getSession(cookieHeader, options) {\n      let id = cookieHeader && (await cookie.parse(cookieHeader, options));\n      let data = id && (await readData(id));\n      return createSession(data || {}, id || \"\");\n    },\n\n    async commitSession(session, options) {\n      let {\n        id,\n        data\n      } = session;\n\n      if (id) {\n        await updateData(id, data, cookie.expires);\n      } else {\n        id = await createData(data, cookie.expires);\n      }\n\n      return cookie.serialize(id, options);\n    },\n\n    async destroySession(session, options) {\n      await deleteData(session.id);\n      return cookie.serialize(\"\", { ...options,\n        expires: new Date(0)\n      });\n    }\n\n  };\n};\nfunction warnOnceAboutSigningSessionCookie(cookie) {\n  warnOnce(cookie.isSigned, `The \"${cookie.name}\" cookie is not signed, but session cookies should be ` + `signed to prevent tampering on the client before they are sent back to the ` + `server. See https://remix.run/api/remix#signing-cookies ` + `for more information.`);\n}\n\nexport { createSession, createSessionStorageFactory, isSession, warnOnceAboutSigningSessionCookie };\n", "/**\n * @remix-run/server-runtime v1.3.3\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\nimport { isCookie } from '../cookies.js';\nimport { warnOnceAboutSigningSessionCookie, createSession } from '../sessions.js';\n\n/**\n * Creates and returns a SessionStorage object that stores all session data\n * directly in the session cookie itself.\n *\n * This has the advantage that no database or other backend services are\n * needed, and can help to simplify some load-balanced scenarios. However, it\n * also has the limitation that serialized session data may not exceed the\n * browser's maximum cookie size. Trade-offs!\n *\n * @see https://remix.run/api/remix#createcookiesessionstorage\n */\nconst createCookieSessionStorageFactory = createCookie => ({\n  cookie: cookieArg\n} = {}) => {\n  let cookie = isCookie(cookieArg) ? cookieArg : createCookie((cookieArg === null || cookieArg === void 0 ? void 0 : cookieArg.name) || \"__session\", cookieArg);\n  warnOnceAboutSigningSessionCookie(cookie);\n  return {\n    async getSession(cookieHeader, options) {\n      return createSession(cookieHeader && (await cookie.parse(cookieHeader, options)) || {});\n    },\n\n    async commitSession(session, options) {\n      return cookie.serialize(session.data, options);\n    },\n\n    async destroySession(_session, options) {\n      return cookie.serialize(\"\", { ...options,\n        expires: new Date(0)\n      });\n    }\n\n  };\n};\n\nexport { createCookieSessionStorageFactory };\n", "/**\n * @remix-run/server-runtime v1.3.3\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\n/**\n * Creates and returns a simple in-memory SessionStorage object, mostly useful\n * for testing and as a reference implementation.\n *\n * Note: This storage does not scale beyond a single process, so it is not\n * suitable for most production scenarios.\n *\n * @see https://remix.run/api/remix#creatememorysessionstorage\n */\nconst createMemorySessionStorageFactory = createSessionStorage => ({\n  cookie\n} = {}) => {\n  let uniqueId = 0;\n  let map = new Map();\n  return createSessionStorage({\n    cookie,\n\n    async createData(data, expires) {\n      let id = (++uniqueId).toString();\n      map.set(id, {\n        data,\n        expires\n      });\n      return id;\n    },\n\n    async readData(id) {\n      if (map.has(id)) {\n        let {\n          data,\n          expires\n        } = map.get(id);\n\n        if (!expires || expires > new Date()) {\n          return data;\n        } // Remove expired session data.\n\n\n        if (expires) map.delete(id);\n      }\n\n      return null;\n    },\n\n    async updateData(id, data, expires) {\n      map.set(id, {\n        data,\n        expires\n      });\n    },\n\n    async deleteData(id) {\n      map.delete(id);\n    }\n\n  });\n};\n\nexport { createMemorySessionStorageFactory };\n", "/**\n * @remix-run/server-runtime v1.3.3\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\nexport { createCookieFactory, isCookie } from './cookies.js';\nexport { json, redirect } from './responses.js';\nexport { createRequestHandler } from './server.js';\nexport { createSession, createSessionStorageFactory, isSession } from './sessions.js';\nexport { createCookieSessionStorageFactory } from './sessions/cookieStorage.js';\nexport { createMemorySessionStorageFactory } from './sessions/memoryStorage.js';\n", "/**\n * @remix-run/cloudflare v1.3.3\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nconst encoder = new TextEncoder();\nconst sign = async (value, secret) => {\n  let key = await createKey(secret, [\"sign\"]);\n  let data = encoder.encode(value);\n  let signature = await crypto.subtle.sign(\"HMAC\", key, data);\n  let hash = btoa(String.fromCharCode(...new Uint8Array(signature))).replace(/=+$/, \"\");\n  return value + \".\" + hash;\n};\nconst unsign = async (signed, secret) => {\n  let index = signed.lastIndexOf(\".\");\n  let value = signed.slice(0, index);\n  let hash = signed.slice(index + 1);\n  let key = await createKey(secret, [\"verify\"]);\n  let data = encoder.encode(value);\n  let signature = byteStringToUint8Array(atob(hash));\n  let valid = await crypto.subtle.verify(\"HMAC\", key, signature, data);\n  return valid ? value : false;\n};\n\nasync function createKey(secret, usages) {\n  let key = await crypto.subtle.importKey(\"raw\", encoder.encode(secret), {\n    name: \"HMAC\",\n    hash: \"SHA-256\"\n  }, false, usages);\n  return key;\n}\n\nfunction byteStringToUint8Array(byteString) {\n  let array = new Uint8Array(byteString.length);\n\n  for (let i = 0; i < byteString.length; i++) {\n    array[i] = byteString.charCodeAt(i);\n  }\n\n  return array;\n}\n\nexports.sign = sign;\nexports.unsign = unsign;\n", "/**\n * @remix-run/cloudflare v1.3.3\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar serverRuntime = require('@remix-run/server-runtime');\nvar crypto = require('./crypto.js');\n\nconst createCookie = serverRuntime.createCookieFactory({\n  sign: crypto.sign,\n  unsign: crypto.unsign\n});\nconst createCookieSessionStorage = serverRuntime.createCookieSessionStorageFactory(createCookie);\nconst createSessionStorage = serverRuntime.createSessionStorageFactory(createCookie);\nconst createMemorySessionStorage = serverRuntime.createMemorySessionStorageFactory(createSessionStorage);\n\nexports.createCookie = createCookie;\nexports.createCookieSessionStorage = createCookieSessionStorage;\nexports.createMemorySessionStorage = createMemorySessionStorage;\nexports.createSessionStorage = createSessionStorage;\n", "/**\n * @remix-run/cloudflare v1.3.3\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar implementations = require('../implementations.js');\n\n/**\n * Creates a SessionStorage that stores session data in the Clouldflare KV Store.\n *\n * The advantage of using this instead of cookie session storage is that\n * KV Store may contain much more data than cookies.\n */\nfunction createCloudflareKVSessionStorage({\n  cookie,\n  kv\n}) {\n  return implementations.createSessionStorage({\n    cookie,\n\n    async createData(data, expires) {\n      while (true) {\n        let randomBytes = new Uint8Array(8);\n        crypto.getRandomValues(randomBytes); // This storage manages an id space of 2^64 ids, which is far greater\n        // than the maximum number of files allowed on an NTFS or ext4 volume\n        // (2^32). However, the larger id space should help to avoid collisions\n        // with existing ids when creating new sessions, which speeds things up.\n\n        let id = [...randomBytes].map(x => x.toString(16).padStart(2, \"0\")).join(\"\");\n\n        if (await kv.get(id, \"json\")) {\n          continue;\n        }\n\n        await kv.put(id, JSON.stringify(data), {\n          expiration: expires ? Math.round(expires.getTime() / 1000) : undefined\n        });\n        return id;\n      }\n    },\n\n    async readData(id) {\n      let session = await kv.get(id);\n\n      if (!session) {\n        return null;\n      }\n\n      return JSON.parse(session);\n    },\n\n    async updateData(id, data, expires) {\n      await kv.put(id, JSON.stringify(data), {\n        expiration: expires ? Math.round(expires.getTime() / 1000) : undefined\n      });\n    },\n\n    async deleteData(id) {\n      await kv.delete(id);\n    }\n\n  });\n}\n\nexports.createCloudflareKVSessionStorage = createCloudflareKVSessionStorage;\n", "/**\n * @remix-run/cloudflare v1.3.3\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar cloudflareKVSessionStorage = require('./sessions/cloudflareKVSessionStorage.js');\nvar implementations = require('./implementations.js');\nvar serverRuntime = require('@remix-run/server-runtime');\n\n\n\nexports.createCloudflareKVSessionStorage = cloudflareKVSessionStorage.createCloudflareKVSessionStorage;\nexports.createCookie = implementations.createCookie;\nexports.createCookieSessionStorage = implementations.createCookieSessionStorage;\nexports.createMemorySessionStorage = implementations.createMemorySessionStorage;\nexports.createSessionStorage = implementations.createSessionStorage;\nObject.defineProperty(exports, 'createRequestHandler', {\n  enumerable: true,\n  get: function () { return serverRuntime.createRequestHandler; }\n});\nObject.defineProperty(exports, 'createSession', {\n  enumerable: true,\n  get: function () { return serverRuntime.createSession; }\n});\nObject.defineProperty(exports, 'isCookie', {\n  enumerable: true,\n  get: function () { return serverRuntime.isCookie; }\n});\nObject.defineProperty(exports, 'isSession', {\n  enumerable: true,\n  get: function () { return serverRuntime.isSession; }\n});\nObject.defineProperty(exports, 'json', {\n  enumerable: true,\n  get: function () { return serverRuntime.json; }\n});\nObject.defineProperty(exports, 'redirect', {\n  enumerable: true,\n  get: function () { return serverRuntime.redirect; }\n});\n", "/**\n * @remix-run/react v1.3.3\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\nimport { createBrowserHistory } from 'history';\nimport * as React from 'react';\nimport { RemixEntry } from './components.js';\n\n// TODO: We eventually might not want to import anything directly from `history`\n\n/**\n * The entry point for a Remix app when it is rendered in the browser (in\n * `app/entry.client.js`). This component is used by React to hydrate the HTML\n * that was received from the server.\n */\nfunction RemixBrowser(_props) {\n  let historyRef = React.useRef();\n\n  if (historyRef.current == null) {\n    historyRef.current = createBrowserHistory({\n      window\n    });\n  }\n\n  let history = historyRef.current;\n  let [state, dispatch] = React.useReducer((_, update) => update, {\n    action: history.action,\n    location: history.location\n  });\n  React.useLayoutEffect(() => history.listen(dispatch), [history]);\n  let entryContext = window.__remixContext;\n  entryContext.manifest = window.__remixManifest;\n  entryContext.routeModules = window.__remixRouteModules; // In the browser, we don't need this because a) in the case of loader\n  // errors we already know the order and b) in the case of render errors\n  // React knows the order and handles error boundaries normally.\n\n  entryContext.appState.trackBoundaries = false;\n  entryContext.appState.trackCatchBoundaries = false;\n  return /*#__PURE__*/React.createElement(RemixEntry, {\n    context: entryContext,\n    action: state.action,\n    location: state.location,\n    navigator: history\n  });\n}\n\nexport { RemixBrowser };\n", "/**\n * @remix-run/react v1.3.3\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\nimport { extends as _extends } from './_virtual/_rollupPluginBabelHelpers.js';\nimport * as React from 'react';\nimport { useHref, NavLink as NavLink$1, Link as Link$1, useLocation, useResolvedPath, useNavigate, Router, useRoutes } from 'react-router-dom';\nimport { RemixErrorBoundary, RemixRootDefaultErrorBoundary, RemixCatchBoundary, RemixRootDefaultCatchBoundary } from './errorBoundaries.js';\nimport invariant from './invariant.js';\nimport { getLinksForMatches, isPageLinkDescriptor, getNewMatchesForLinks, getDataLinkHrefs, getModuleLinkHrefs, getStylesheetPrefetchLinks } from './links.js';\nimport { createHtml } from './markup.js';\nimport { createClientRoutes } from './routes.js';\nimport { matchClientRoutes } from './routeMatching.js';\nimport { createTransitionManager } from './transition.js';\n\nconst RemixEntryContext = /*#__PURE__*/React.createContext(undefined);\n\nfunction useRemixEntryContext() {\n  let context = React.useContext(RemixEntryContext);\n  invariant(context, \"You must render this element inside a <Remix> element\");\n  return context;\n}\n\nfunction RemixEntry({\n  context: entryContext,\n  action,\n  location: historyLocation,\n  navigator: _navigator,\n  static: staticProp = false\n}) {\n  let {\n    manifest,\n    routeData: documentLoaderData,\n    actionData: documentActionData,\n    routeModules,\n    serverHandoffString,\n    appState: entryComponentDidCatchEmulator\n  } = entryContext;\n  let clientRoutes = React.useMemo(() => createClientRoutes(manifest.routes, routeModules, RemixRoute), [manifest, routeModules]);\n  let [clientState, setClientState] = React.useState(entryComponentDidCatchEmulator);\n  let [transitionManager] = React.useState(() => {\n    return createTransitionManager({\n      routes: clientRoutes,\n      actionData: documentActionData,\n      loaderData: documentLoaderData,\n      location: historyLocation,\n      catch: entryComponentDidCatchEmulator.catch,\n      catchBoundaryId: entryComponentDidCatchEmulator.catchBoundaryRouteId,\n      onRedirect: _navigator.replace,\n      onChange: state => {\n        setClientState({\n          catch: state.catch,\n          error: state.error,\n          catchBoundaryRouteId: state.catchBoundaryId,\n          loaderBoundaryRouteId: state.errorBoundaryId,\n          renderBoundaryRouteId: null,\n          trackBoundaries: false,\n          trackCatchBoundaries: false\n        });\n      }\n    });\n  }); // Ensures pushes interrupting pending navigations use replace\n  // TODO: Move this to React Router\n\n  let navigator = React.useMemo(() => {\n    let push = (to, state) => {\n      return transitionManager.getState().transition.state !== \"idle\" ? _navigator.replace(to, state) : _navigator.push(to, state);\n    };\n\n    return { ..._navigator,\n      push\n    };\n  }, [_navigator, transitionManager]);\n  let {\n    location,\n    matches,\n    loaderData,\n    actionData\n  } = transitionManager.getState(); // Send new location to the transition manager\n\n  React.useEffect(() => {\n    let {\n      location\n    } = transitionManager.getState();\n    if (historyLocation === location) return;\n    transitionManager.send({\n      type: \"navigation\",\n      location: historyLocation,\n      submission: consumeNextNavigationSubmission(),\n      action\n    });\n  }, [transitionManager, historyLocation, action]); // If we tried to render and failed, and the app threw before rendering any\n  // routes, get the error and pass it to the ErrorBoundary to emulate\n  // `componentDidCatch`\n\n  let ssrErrorBeforeRoutesRendered = clientState.error && clientState.renderBoundaryRouteId === null && clientState.loaderBoundaryRouteId === null ? deserializeError(clientState.error) : undefined;\n  let ssrCatchBeforeRoutesRendered = clientState.catch && clientState.catchBoundaryRouteId === null ? clientState.catch : undefined;\n  return /*#__PURE__*/React.createElement(RemixEntryContext.Provider, {\n    value: {\n      matches,\n      manifest,\n      appState: clientState,\n      routeModules,\n      serverHandoffString,\n      clientRoutes,\n      routeData: loaderData,\n      actionData,\n      transitionManager\n    }\n  }, /*#__PURE__*/React.createElement(RemixErrorBoundary, {\n    location: location,\n    component: RemixRootDefaultErrorBoundary,\n    error: ssrErrorBeforeRoutesRendered\n  }, /*#__PURE__*/React.createElement(RemixCatchBoundary, {\n    location: location,\n    component: RemixRootDefaultCatchBoundary,\n    catch: ssrCatchBeforeRoutesRendered\n  }, /*#__PURE__*/React.createElement(Router, {\n    navigationType: action,\n    location: location,\n    navigator: navigator,\n    static: staticProp\n  }, /*#__PURE__*/React.createElement(Routes, null)))));\n}\n\nfunction deserializeError(data) {\n  let error = new Error(data.message);\n  error.stack = data.stack;\n  return error;\n}\n\nfunction Routes() {\n  // TODO: Add `renderMatches` function to RR that we can use and then we don't\n  // need this component, we can just `renderMatches` from RemixEntry\n  let {\n    clientRoutes\n  } = useRemixEntryContext(); // fallback to the root if we don't have a match\n\n  let element = useRoutes(clientRoutes) || clientRoutes[0].element;\n  return element;\n} ////////////////////////////////////////////////////////////////////////////////\n// RemixRoute\n\n\nconst RemixRouteContext = /*#__PURE__*/React.createContext(undefined);\n\nfunction useRemixRouteContext() {\n  let context = React.useContext(RemixRouteContext);\n  invariant(context, \"You must render this element in a remix route element\");\n  return context;\n}\n\nfunction DefaultRouteComponent({\n  id\n}) {\n  throw new Error(`Route \"${id}\" has no component! Please go add a \\`default\\` export in the route module file.\\n` + \"If you were trying to navigate or submit to a resource route, use `<a>` instead of `<Link>` or `<Form reloadDocument>`.\");\n}\n\nfunction RemixRoute({\n  id\n}) {\n  let location = useLocation();\n  let {\n    routeData,\n    routeModules,\n    appState\n  } = useRemixEntryContext();\n  let data = routeData[id];\n  let {\n    default: Component,\n    CatchBoundary,\n    ErrorBoundary\n  } = routeModules[id];\n  let element = Component ? /*#__PURE__*/React.createElement(Component, null) : /*#__PURE__*/React.createElement(DefaultRouteComponent, {\n    id: id\n  });\n  let context = {\n    data,\n    id\n  };\n\n  if (CatchBoundary) {\n    // If we tried to render and failed, and this route threw the error, find it\n    // and pass it to the ErrorBoundary to emulate `componentDidCatch`\n    let maybeServerCaught = appState.catch && appState.catchBoundaryRouteId === id ? appState.catch : undefined; // This needs to run after we check for the error from a previous render,\n    // otherwise we will incorrectly render this boundary for a loader error\n    // deeper in the tree.\n\n    if (appState.trackCatchBoundaries) {\n      appState.catchBoundaryRouteId = id;\n    }\n\n    context = maybeServerCaught ? {\n      id,\n\n      get data() {\n        console.error(\"You cannot `useLoaderData` in a catch boundary.\");\n        return undefined;\n      }\n\n    } : {\n      id,\n      data\n    };\n    element = /*#__PURE__*/React.createElement(RemixCatchBoundary, {\n      location: location,\n      component: CatchBoundary,\n      catch: maybeServerCaught\n    }, element);\n  } // Only wrap in error boundary if the route defined one, otherwise let the\n  // error bubble to the parent boundary. We could default to using error\n  // boundaries around every route, but now if the app doesn't want users\n  // seeing the default Remix ErrorBoundary component, they *must* define an\n  // error boundary for *every* route and that would be annoying. Might as\n  // well make it required at that point.\n  //\n  // By conditionally wrapping like this, we allow apps to define a top level\n  // ErrorBoundary component and be done with it. Then, if they want to, they\n  // can add more specific boundaries by exporting ErrorBoundary components\n  // for whichever routes they please.\n  //\n  // NOTE: this kind of logic will move into React Router\n\n\n  if (ErrorBoundary) {\n    // If we tried to render and failed, and this route threw the error, find it\n    // and pass it to the ErrorBoundary to emulate `componentDidCatch`\n    let maybeServerRenderError = appState.error && (appState.renderBoundaryRouteId === id || appState.loaderBoundaryRouteId === id) ? deserializeError(appState.error) : undefined; // This needs to run after we check for the error from a previous render,\n    // otherwise we will incorrectly render this boundary for a loader error\n    // deeper in the tree.\n\n    if (appState.trackBoundaries) {\n      appState.renderBoundaryRouteId = id;\n    }\n\n    context = maybeServerRenderError ? {\n      id,\n\n      get data() {\n        console.error(\"You cannot `useLoaderData` in an error boundary.\");\n        return undefined;\n      }\n\n    } : {\n      id,\n      data\n    };\n    element = /*#__PURE__*/React.createElement(RemixErrorBoundary, {\n      location: location,\n      component: ErrorBoundary,\n      error: maybeServerRenderError\n    }, element);\n  } // It's important for the route context to be above the error boundary so that\n  // a call to `useLoaderData` doesn't accidentally get the parents route's data.\n\n\n  return /*#__PURE__*/React.createElement(RemixRouteContext.Provider, {\n    value: context\n  }, element);\n} ////////////////////////////////////////////////////////////////////////////////\n// Public API\n\n/**\n * Defines the prefetching behavior of the link:\n *\n * - \"intent\": Fetched when the user focuses or hovers the link\n * - \"render\": Fetched when the link is rendered\n * - \"none\": Never fetched\n */\n\nfunction usePrefetchBehavior(prefetch, theirElementProps) {\n  let [maybePrefetch, setMaybePrefetch] = React.useState(false);\n  let [shouldPrefetch, setShouldPrefetch] = React.useState(false);\n  let {\n    onFocus,\n    onBlur,\n    onMouseEnter,\n    onMouseLeave,\n    onTouchStart\n  } = theirElementProps;\n  React.useEffect(() => {\n    if (prefetch === \"render\") {\n      setShouldPrefetch(true);\n    }\n  }, [prefetch]);\n\n  let setIntent = () => {\n    if (prefetch === \"intent\") {\n      setMaybePrefetch(true);\n    }\n  };\n\n  let cancelIntent = () => {\n    if (prefetch === \"intent\") {\n      setMaybePrefetch(false);\n    }\n  };\n\n  React.useEffect(() => {\n    if (maybePrefetch) {\n      let id = setTimeout(() => {\n        setShouldPrefetch(true);\n      }, 100);\n      return () => {\n        clearTimeout(id);\n      };\n    }\n  }, [maybePrefetch]);\n  return [shouldPrefetch, {\n    onFocus: composeEventHandlers(onFocus, setIntent),\n    onBlur: composeEventHandlers(onBlur, cancelIntent),\n    onMouseEnter: composeEventHandlers(onMouseEnter, setIntent),\n    onMouseLeave: composeEventHandlers(onMouseLeave, cancelIntent),\n    onTouchStart: composeEventHandlers(onTouchStart, setIntent)\n  }];\n}\n/**\n * A special kind of `<Link>` that knows whether or not it is \"active\".\n *\n * @see https://remix.run/api/remix#navlink\n */\n\n\nlet NavLink = /*#__PURE__*/React.forwardRef(({\n  to,\n  prefetch = \"none\",\n  ...props\n}, forwardedRef) => {\n  let href = useHref(to);\n  let [shouldPrefetch, prefetchHandlers] = usePrefetchBehavior(prefetch, props);\n  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(NavLink$1, _extends({\n    ref: forwardedRef,\n    to: to\n  }, props, prefetchHandlers)), shouldPrefetch ? /*#__PURE__*/React.createElement(PrefetchPageLinks, {\n    page: href\n  }) : null);\n});\nNavLink.displayName = \"NavLink\";\n/**\n * This component renders an anchor tag and is the primary way the user will\n * navigate around your website.\n *\n * @see https://remix.run/api/remix#link\n */\n\nlet Link = /*#__PURE__*/React.forwardRef(({\n  to,\n  prefetch = \"none\",\n  ...props\n}, forwardedRef) => {\n  let href = useHref(to);\n  let [shouldPrefetch, prefetchHandlers] = usePrefetchBehavior(prefetch, props);\n  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(Link$1, _extends({\n    ref: forwardedRef,\n    to: to\n  }, props, prefetchHandlers)), shouldPrefetch ? /*#__PURE__*/React.createElement(PrefetchPageLinks, {\n    page: href\n  }) : null);\n});\nLink.displayName = \"Link\";\nfunction composeEventHandlers(theirHandler, ourHandler) {\n  return event => {\n    theirHandler && theirHandler(event);\n\n    if (!event.defaultPrevented) {\n      ourHandler(event);\n    }\n  };\n}\n/**\n * Renders the `<link>` tags for the current routes.\n *\n * @see https://remix.run/api/remix#meta-links-scripts\n */\n\nfunction Links() {\n  let {\n    matches,\n    routeModules,\n    manifest\n  } = useRemixEntryContext();\n  let links = React.useMemo(() => getLinksForMatches(matches, routeModules, manifest), [matches, routeModules, manifest]);\n  return /*#__PURE__*/React.createElement(React.Fragment, null, links.map(link => isPageLinkDescriptor(link) ? /*#__PURE__*/React.createElement(PrefetchPageLinks, _extends({\n    key: link.page\n  }, link)) : /*#__PURE__*/React.createElement(\"link\", _extends({\n    key: link.rel + link.href\n  }, link))));\n}\n/**\n * This component renders all of the `<link rel=\"prefetch\">` and\n * `<link rel=\"modulepreload\"/>` tags for all the assets (data, modules, css) of\n * a given page.\n *\n * @param props\n * @param props.page\n * @see https://remix.run/api/remix#prefetchpagelinks-\n */\n\nfunction PrefetchPageLinks({\n  page,\n  ...dataLinkProps\n}) {\n  let {\n    clientRoutes\n  } = useRemixEntryContext();\n  let matches = React.useMemo(() => matchClientRoutes(clientRoutes, page), [clientRoutes, page]);\n\n  if (!matches) {\n    console.warn(`Tried to prefetch ${page} but no routes matched.`);\n    return null;\n  }\n\n  return /*#__PURE__*/React.createElement(PrefetchPageLinksImpl, _extends({\n    page: page,\n    matches: matches\n  }, dataLinkProps));\n}\n\nfunction usePrefetchedStylesheets(matches) {\n  let {\n    routeModules\n  } = useRemixEntryContext();\n  let [styleLinks, setStyleLinks] = React.useState([]);\n  React.useEffect(() => {\n    let interrupted = false;\n    getStylesheetPrefetchLinks(matches, routeModules).then(links => {\n      if (!interrupted) setStyleLinks(links);\n    });\n    return () => {\n      interrupted = true;\n    };\n  }, [matches, routeModules]);\n  return styleLinks;\n}\n\nfunction PrefetchPageLinksImpl({\n  page,\n  matches: nextMatches,\n  ...linkProps\n}) {\n  let location = useLocation();\n  let {\n    matches,\n    manifest\n  } = useRemixEntryContext();\n  let newMatchesForData = React.useMemo(() => getNewMatchesForLinks(page, nextMatches, matches, location, \"data\"), [page, nextMatches, matches, location]);\n  let newMatchesForAssets = React.useMemo(() => getNewMatchesForLinks(page, nextMatches, matches, location, \"assets\"), [page, nextMatches, matches, location]);\n  let dataHrefs = React.useMemo(() => getDataLinkHrefs(page, newMatchesForData, manifest), [newMatchesForData, page, manifest]);\n  let moduleHrefs = React.useMemo(() => getModuleLinkHrefs(newMatchesForAssets, manifest), [newMatchesForAssets, manifest]); // needs to be a hook with async behavior because we need the modules, not\n  // just the manifest like the other links in here.\n\n  let styleLinks = usePrefetchedStylesheets(newMatchesForAssets);\n  return /*#__PURE__*/React.createElement(React.Fragment, null, dataHrefs.map(href => /*#__PURE__*/React.createElement(\"link\", _extends({\n    key: href,\n    rel: \"prefetch\",\n    as: \"fetch\",\n    href: href\n  }, linkProps))), moduleHrefs.map(href => /*#__PURE__*/React.createElement(\"link\", _extends({\n    key: href,\n    rel: \"modulepreload\",\n    href: href\n  }, linkProps))), styleLinks.map(link =>\n  /*#__PURE__*/\n  // these don't spread `linkProps` because they are full link descriptors\n  // already with their own props\n  React.createElement(\"link\", _extends({\n    key: link.href\n  }, link))));\n}\n/**\n * Renders the `<title>` and `<meta>` tags for the current routes.\n *\n * @see https://remix.run/api/remix#meta-links-scripts\n */\n\n\nfunction Meta() {\n  let {\n    matches,\n    routeData,\n    routeModules\n  } = useRemixEntryContext();\n  let location = useLocation();\n  let meta = {};\n  let parentsData = {};\n\n  for (let match of matches) {\n    let routeId = match.route.id;\n    let data = routeData[routeId];\n    let params = match.params;\n    let routeModule = routeModules[routeId];\n\n    if (routeModule.meta) {\n      let routeMeta = typeof routeModule.meta === \"function\" ? routeModule.meta({\n        data,\n        parentsData,\n        params,\n        location\n      }) : routeModule.meta;\n      Object.assign(meta, routeMeta);\n    }\n\n    parentsData[routeId] = data;\n  }\n\n  return /*#__PURE__*/React.createElement(React.Fragment, null, Object.entries(meta).map(([name, value]) => {\n    if (!value) return null; // Open Graph tags use the `property` attribute, while other meta tags\n    // use `name`. See https://ogp.me/\n\n    let isOpenGraphTag = name.startsWith(\"og:\");\n    return name === \"title\" ? /*#__PURE__*/React.createElement(\"title\", {\n      key: \"title\"\n    }, value) : [\"charset\", \"charSet\"].includes(name) ? /*#__PURE__*/React.createElement(\"meta\", {\n      key: \"charset\",\n      charSet: value\n    }) : Array.isArray(value) ? value.map(content => isOpenGraphTag ? /*#__PURE__*/React.createElement(\"meta\", {\n      key: name + content,\n      property: name,\n      content: content\n    }) : /*#__PURE__*/React.createElement(\"meta\", {\n      key: name + content,\n      name: name,\n      content: content\n    })) : isOpenGraphTag ? /*#__PURE__*/React.createElement(\"meta\", {\n      key: name,\n      property: name,\n      content: value\n    }) : /*#__PURE__*/React.createElement(\"meta\", {\n      key: name,\n      name: name,\n      content: value\n    });\n  }));\n}\n/**\n * Tracks whether Remix has finished hydrating or not, so scripts can be skipped\n * during client-side updates.\n */\n\nlet isHydrated = false;\n\n/**\n * Renders the `<script>` tags needed for the initial render. Bundles for\n * additional routes are loaded later as needed.\n *\n * @param props Additional properties to add to each script tag that is rendered.\n * In addition to scripts, \\<link rel=\"modulepreload\"> tags receive the crossOrigin\n * property if provided.\n *\n * @see https://remix.run/api/remix#meta-links-scripts\n */\nfunction Scripts(props) {\n  let {\n    manifest,\n    matches,\n    pendingLocation,\n    clientRoutes,\n    serverHandoffString\n  } = useRemixEntryContext();\n  React.useEffect(() => {\n    isHydrated = true;\n  }, []);\n  let initialScripts = React.useMemo(() => {\n    let contextScript = serverHandoffString ? `window.__remixContext = ${serverHandoffString};` : \"\";\n    let routeModulesScript = `${matches.map((match, index) => `import * as route${index} from ${JSON.stringify(manifest.routes[match.route.id].module)};`).join(\"\\n\")}\nwindow.__remixRouteModules = {${matches.map((match, index) => `${JSON.stringify(match.route.id)}:route${index}`).join(\",\")}};`;\n    return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(\"script\", _extends({}, props, {\n      suppressHydrationWarning: true,\n      dangerouslySetInnerHTML: createHtml(contextScript)\n    })), /*#__PURE__*/React.createElement(\"script\", _extends({}, props, {\n      src: manifest.url\n    })), /*#__PURE__*/React.createElement(\"script\", _extends({}, props, {\n      dangerouslySetInnerHTML: createHtml(routeModulesScript),\n      type: \"module\"\n    })), /*#__PURE__*/React.createElement(\"script\", _extends({}, props, {\n      src: manifest.entry.module,\n      type: \"module\"\n    }))); // disabled deps array because we are purposefully only rendering this once\n    // for hydration, after that we want to just continue rendering the initial\n    // scripts as they were when the page first loaded\n    // eslint-disable-next-line\n  }, []); // avoid waterfall when importing the next route module\n\n  let nextMatches = React.useMemo(() => {\n    if (pendingLocation) {\n      // FIXME: can probably use transitionManager `nextMatches`\n      let matches = matchClientRoutes(clientRoutes, pendingLocation);\n      invariant(matches, `No routes match path \"${pendingLocation.pathname}\"`);\n      return matches;\n    }\n\n    return [];\n  }, [pendingLocation, clientRoutes]);\n  let routePreloads = matches.concat(nextMatches).map(match => {\n    let route = manifest.routes[match.route.id];\n    return (route.imports || []).concat([route.module]);\n  }).flat(1);\n  let preloads = manifest.entry.imports.concat(routePreloads);\n  return /*#__PURE__*/React.createElement(React.Fragment, null, dedupe(preloads).map(path => /*#__PURE__*/React.createElement(\"link\", {\n    key: path,\n    rel: \"modulepreload\",\n    href: path,\n    crossOrigin: props.crossOrigin\n  })), isHydrated ? null : initialScripts);\n}\n\nfunction dedupe(array) {\n  return [...new Set(array)];\n}\n\n/**\n * A Remix-aware `<form>`. It behaves like a normal form except that the\n * interaction with the server is with `fetch` instead of new document\n * requests, allowing components to add nicer UX to the page as the form is\n * submitted and returns with data.\n *\n * @see https://remix.run/api/remix#form\n */\nlet Form = /*#__PURE__*/React.forwardRef((props, ref) => {\n  return /*#__PURE__*/React.createElement(FormImpl, _extends({}, props, {\n    ref: ref\n  }));\n});\nForm.displayName = \"Form\";\nlet FormImpl = /*#__PURE__*/React.forwardRef(({\n  reloadDocument = false,\n  replace = false,\n  method = \"get\",\n  action = \".\",\n  encType = \"application/x-www-form-urlencoded\",\n  fetchKey,\n  onSubmit,\n  ...props\n}, forwardedRef) => {\n  let submit = useSubmitImpl(fetchKey);\n  let formMethod = method.toLowerCase() === \"get\" ? \"get\" : \"post\";\n  let formAction = useFormAction(action);\n  let formRef = React.useRef();\n  let ref = useComposedRefs(forwardedRef, formRef); // When calling `submit` on the form element itself, we don't get data from\n  // the button that submitted the event. For example:\n  //\n  //   <Form>\n  //     <button name=\"something\" value=\"whatever\">Submit</button>\n  //   </Form>\n  //\n  // formData.get(\"something\") should be \"whatever\", but we don't get that\n  // unless we call submit on the clicked button itself.\n  //\n  // To figure out which button triggered the submit, we'll attach a click\n  // event listener to the form. The click event is always triggered before\n  // the submit event (even when submitting via keyboard when focused on\n  // another form field, yeeeeet) so we should have access to that button's\n  // data for use in the submit handler.\n\n  let clickedButtonRef = React.useRef();\n  React.useEffect(() => {\n    let form = formRef.current;\n    if (!form) return;\n\n    function handleClick(event) {\n      if (!(event.target instanceof Element)) return;\n      let submitButton = event.target.closest(\"button,input[type=submit]\");\n\n      if (submitButton && submitButton.form === form && submitButton.type === \"submit\") {\n        clickedButtonRef.current = submitButton;\n      }\n    }\n\n    window.addEventListener(\"click\", handleClick);\n    return () => {\n      window.removeEventListener(\"click\", handleClick);\n    };\n  }, []);\n  return /*#__PURE__*/React.createElement(\"form\", _extends({\n    ref: ref,\n    method: formMethod,\n    action: formAction,\n    encType: encType,\n    onSubmit: reloadDocument ? undefined : event => {\n      onSubmit && onSubmit(event);\n      if (event.defaultPrevented) return;\n      event.preventDefault();\n      submit(clickedButtonRef.current || event.currentTarget, {\n        method,\n        replace\n      });\n      clickedButtonRef.current = null;\n    }\n  }, props));\n});\nFormImpl.displayName = \"FormImpl\";\n/**\n * Resolves a `<form action>` path relative to the current route.\n *\n * @see https://remix.run/api/remix#useformaction\n */\n\nfunction useFormAction(action = \".\", // TODO: Remove method param in v2 as it's no longer needed and is a breaking change\nmethod = \"get\") {\n  let {\n    id\n  } = useRemixRouteContext();\n  let path = useResolvedPath(action);\n  let search = path.search;\n  let isIndexRoute = id.endsWith(\"/index\");\n\n  if (action === \".\" && isIndexRoute) {\n    search = search ? search.replace(/^\\?/, \"?index&\") : \"?index\";\n  }\n\n  return path.pathname + search;\n}\n\n/**\n * Returns a function that may be used to programmatically submit a form (or\n * some arbitrary data) to the server.\n *\n * @see https://remix.run/api/remix#usesubmit\n */\nfunction useSubmit() {\n  return useSubmitImpl();\n}\nlet defaultMethod = \"get\";\nlet defaultEncType = \"application/x-www-form-urlencoded\";\nfunction useSubmitImpl(key) {\n  let navigate = useNavigate();\n  let defaultAction = useFormAction();\n  let {\n    transitionManager\n  } = useRemixEntryContext();\n  return React.useCallback((target, options = {}) => {\n    let method;\n    let action;\n    let encType;\n    let formData;\n\n    if (isFormElement(target)) {\n      let submissionTrigger = options.submissionTrigger;\n      method = options.method || target.getAttribute(\"method\") || defaultMethod;\n      action = options.action || target.getAttribute(\"action\") || defaultAction;\n      encType = options.encType || target.getAttribute(\"enctype\") || defaultEncType;\n      formData = new FormData(target);\n\n      if (submissionTrigger && submissionTrigger.name) {\n        formData.append(submissionTrigger.name, submissionTrigger.value);\n      }\n    } else if (isButtonElement(target) || isInputElement(target) && (target.type === \"submit\" || target.type === \"image\")) {\n      let form = target.form;\n\n      if (form == null) {\n        throw new Error(`Cannot submit a <button> without a <form>`);\n      } // <button>/<input type=\"submit\"> may override attributes of <form>\n\n\n      method = options.method || target.getAttribute(\"formmethod\") || form.getAttribute(\"method\") || defaultMethod;\n      action = options.action || target.getAttribute(\"formaction\") || form.getAttribute(\"action\") || defaultAction;\n      encType = options.encType || target.getAttribute(\"formenctype\") || form.getAttribute(\"enctype\") || defaultEncType;\n      formData = new FormData(form); // Include name + value from a <button>\n\n      if (target.name) {\n        formData.set(target.name, target.value);\n      }\n    } else {\n      if (isHtmlElement(target)) {\n        throw new Error(`Cannot submit element that is not <form>, <button>, or ` + `<input type=\"submit|image\">`);\n      }\n\n      method = options.method || \"get\";\n      action = options.action || defaultAction;\n      encType = options.encType || \"application/x-www-form-urlencoded\";\n\n      if (target instanceof FormData) {\n        formData = target;\n      } else {\n        formData = new FormData();\n\n        if (target instanceof URLSearchParams) {\n          for (let [name, value] of target) {\n            formData.append(name, value);\n          }\n        } else if (target != null) {\n          for (let name of Object.keys(target)) {\n            formData.append(name, target[name]);\n          }\n        }\n      }\n    }\n\n    if (typeof document === \"undefined\") {\n      throw new Error(\"You are calling submit during the server render. \" + \"Try calling submit within a `useEffect` or callback instead.\");\n    }\n\n    let {\n      protocol,\n      host\n    } = window.location;\n    let url = new URL(action, `${protocol}//${host}`);\n\n    if (method.toLowerCase() === \"get\") {\n      for (let [name, value] of formData) {\n        if (typeof value === \"string\") {\n          url.searchParams.append(name, value);\n        } else {\n          throw new Error(`Cannot submit binary form data using GET`);\n        }\n      }\n    }\n\n    let submission = {\n      formData,\n      action: url.pathname + url.search,\n      method: method.toUpperCase(),\n      encType,\n      key: Math.random().toString(36).substr(2, 8)\n    };\n\n    if (key) {\n      transitionManager.send({\n        type: \"fetcher\",\n        href: submission.action,\n        submission,\n        key\n      });\n    } else {\n      setNextNavigationSubmission(submission);\n      navigate(url.pathname + url.search, {\n        replace: options.replace\n      });\n    }\n  }, [defaultAction, key, navigate, transitionManager]);\n}\nlet nextNavigationSubmission;\n\nfunction setNextNavigationSubmission(submission) {\n  nextNavigationSubmission = submission;\n}\n\nfunction consumeNextNavigationSubmission() {\n  let submission = nextNavigationSubmission;\n  nextNavigationSubmission = undefined;\n  return submission;\n}\n\nfunction isHtmlElement(object) {\n  return object != null && typeof object.tagName === \"string\";\n}\n\nfunction isButtonElement(object) {\n  return isHtmlElement(object) && object.tagName.toLowerCase() === \"button\";\n}\n\nfunction isFormElement(object) {\n  return isHtmlElement(object) && object.tagName.toLowerCase() === \"form\";\n}\n\nfunction isInputElement(object) {\n  return isHtmlElement(object) && object.tagName.toLowerCase() === \"input\";\n}\n/**\n * Setup a callback to be fired on the window's `beforeunload` event. This is\n * useful for saving some data to `window.localStorage` just before the page\n * refreshes, which automatically happens on the next `<Link>` click when Remix\n * detects a new version of the app is available on the server.\n *\n * Note: The `callback` argument should be a function created with\n * `React.useCallback()`.\n *\n * @see https://remix.run/api/remix#usebeforeunload\n */\n\n\nfunction useBeforeUnload(callback) {\n  React.useEffect(() => {\n    window.addEventListener(\"beforeunload\", callback);\n    return () => {\n      window.removeEventListener(\"beforeunload\", callback);\n    };\n  }, [callback]);\n}\n/**\n * Returns the current route matches on the page. This is useful for creating\n * layout abstractions with your current routes.\n *\n * @see https://remix.run/api/remix#usematches\n */\n\nfunction useMatches() {\n  let {\n    matches,\n    routeData,\n    routeModules\n  } = useRemixEntryContext();\n  return React.useMemo(() => matches.map(match => {\n    var _routeModules$match$r;\n\n    let {\n      pathname,\n      params\n    } = match;\n    return {\n      id: match.route.id,\n      pathname,\n      params,\n      data: routeData[match.route.id],\n      // if the module fails to load or an error/response is thrown, the module\n      // won't be defined.\n      handle: (_routeModules$match$r = routeModules[match.route.id]) === null || _routeModules$match$r === void 0 ? void 0 : _routeModules$match$r.handle\n    };\n  }), [matches, routeData, routeModules]);\n}\n/**\n * Returns the JSON parsed data from the current route's `loader`.\n *\n * @see https://remix.run/api/remix#useloaderdata\n */\n\nfunction useLoaderData() {\n  return useRemixRouteContext().data;\n}\n/**\n * Returns the JSON parsed data from the current route's `action`.\n *\n * @see https://remix.run/api/remix#useactiondata\n */\n\nfunction useActionData() {\n  let {\n    id: routeId\n  } = useRemixRouteContext();\n  let {\n    transitionManager\n  } = useRemixEntryContext();\n  let {\n    actionData\n  } = transitionManager.getState();\n  return actionData ? actionData[routeId] : undefined;\n}\n/**\n * Returns everything you need to know about a page transition to build pending\n * navigation indicators and optimistic UI on data mutations.\n *\n * @see https://remix.run/api/remix#usetransition\n */\n\nfunction useTransition() {\n  let {\n    transitionManager\n  } = useRemixEntryContext();\n  return transitionManager.getState().transition;\n}\n\nfunction createFetcherForm(fetchKey) {\n  let FetcherForm = /*#__PURE__*/React.forwardRef((props, ref) => {\n    // TODO: make ANOTHER form w/o a fetchKey prop\n    return /*#__PURE__*/React.createElement(FormImpl, _extends({}, props, {\n      ref: ref,\n      fetchKey: fetchKey\n    }));\n  });\n  FetcherForm.displayName = \"fetcher.Form\";\n  return FetcherForm;\n}\n\nlet fetcherId = 0;\n\n/**\n * Interacts with route loaders and actions without causing a navigation. Great\n * for any interaction that stays on the same page.\n *\n * @see https://remix.run/api/remix#usefetcher\n */\nfunction useFetcher() {\n  let {\n    transitionManager\n  } = useRemixEntryContext();\n  let [key] = React.useState(() => String(++fetcherId));\n  let [Form] = React.useState(() => createFetcherForm(key));\n  let [load] = React.useState(() => href => {\n    transitionManager.send({\n      type: \"fetcher\",\n      href,\n      key\n    });\n  });\n  let submit = useSubmitImpl(key);\n  let fetcher = transitionManager.getFetcher(key);\n  let fetcherWithComponents = React.useMemo(() => ({\n    Form,\n    submit,\n    load,\n    ...fetcher\n  }), [fetcher, Form, submit, load]);\n  React.useEffect(() => {\n    // Is this busted when the React team gets real weird and calls effects\n    // twice on mount?  We really just need to garbage collect here when this\n    // fetcher is no longer around.\n    return () => transitionManager.deleteFetcher(key);\n  }, [transitionManager, key]);\n  return fetcherWithComponents;\n}\n/**\n * Provides all fetchers currently on the page. Useful for layouts and parent\n * routes that need to provide pending/optimistic UI regarding the fetch.\n *\n * @see https://remix.run/api/remix#usefetchers\n */\n\nfunction useFetchers() {\n  let {\n    transitionManager\n  } = useRemixEntryContext();\n  let {\n    fetchers\n  } = transitionManager.getState();\n  return [...fetchers.values()];\n} // Dead Code Elimination magic for production builds.\n// This way devs don't have to worry about doing the NODE_ENV check themselves.\n\nconst LiveReload = process.env.NODE_ENV !== \"development\" ? () => null : function LiveReload({\n  port = Number(process.env.REMIX_DEV_SERVER_WS_PORT || 8002)\n}) {\n  let setupLiveReload = (port => {\n    let protocol = location.protocol === \"https:\" ? \"wss:\" : \"ws:\";\n    let host = location.hostname;\n    let socketPath = `${protocol}//${host}:${port}/socket`;\n    let ws = new WebSocket(socketPath);\n\n    ws.onmessage = message => {\n      let event = JSON.parse(message.data);\n\n      if (event.type === \"LOG\") {\n        console.log(event.message);\n      }\n\n      if (event.type === \"RELOAD\") {\n        console.log(\"\uD83D\uDCBF Reloading window ...\");\n        window.location.reload();\n      }\n    };\n\n    ws.onerror = error => {\n      console.log(\"Remix dev asset server web socket error:\");\n      console.error(error);\n    };\n  }).toString();\n\n  return /*#__PURE__*/React.createElement(\"script\", {\n    suppressHydrationWarning: true,\n    dangerouslySetInnerHTML: {\n      __html: `(${setupLiveReload})(${JSON.stringify(port)})`\n    }\n  });\n};\n\nfunction useComposedRefs(...refs) {\n  return React.useCallback(node => {\n    for (let ref of refs) {\n      if (ref == null) continue;\n\n      if (typeof ref === \"function\") {\n        ref(node);\n      } else {\n        try {\n          ref.current = node;\n        } catch (_) {}\n      }\n    } // eslint-disable-next-line react-hooks/exhaustive-deps\n\n  }, refs);\n}\n\nexport { Form, FormImpl, Link, Links, LiveReload, Meta, NavLink, PrefetchPageLinks, RemixEntry, RemixEntryContext, RemixRoute, Scripts, composeEventHandlers, useActionData, useBeforeUnload, useFetcher, useFetchers, useFormAction, useLoaderData, useMatches, useSubmit, useSubmitImpl, useTransition };\n", "/**\n * @remix-run/react v1.3.3\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nexport { _extends as extends };\n", "/**\n * @remix-run/react v1.3.3\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\nimport React__default, { useContext } from 'react';\n\n// TODO: We eventually might not want to import anything directly from `history`\nclass RemixErrorBoundary extends React__default.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      error: props.error || null,\n      location: props.location\n    };\n  }\n\n  static getDerivedStateFromError(error) {\n    return {\n      error\n    };\n  }\n\n  static getDerivedStateFromProps(props, state) {\n    // When we get into an error state, the user will likely click \"back\" to the\n    // previous page that didn't have an error. Because this wraps the entire\n    // application (even the HTML!) that will have no effect--the error page\n    // continues to display. This gives us a mechanism to recover from the error\n    // when the location changes.\n    //\n    // Whether we're in an error state or not, we update the location in state\n    // so that when we are in an error state, it gets reset when a new location\n    // comes in and the user recovers from the error.\n    if (state.location !== props.location) {\n      return {\n        error: props.error || null,\n        location: props.location\n      };\n    } // If we're not changing locations, preserve the location but still surface\n    // any new errors that may come through. We retain the existing error, we do\n    // this because the error provided from the app state may be cleared without\n    // the location changing.\n\n\n    return {\n      error: props.error || state.error,\n      location: state.location\n    };\n  }\n\n  render() {\n    if (this.state.error) {\n      return /*#__PURE__*/React__default.createElement(this.props.component, {\n        error: this.state.error\n      });\n    } else {\n      return this.props.children;\n    }\n  }\n\n}\n/**\n * When app's don't provide a root level ErrorBoundary, we default to this.\n */\n\nfunction RemixRootDefaultErrorBoundary({\n  error\n}) {\n  console.error(error);\n  return /*#__PURE__*/React__default.createElement(\"html\", {\n    lang: \"en\"\n  }, /*#__PURE__*/React__default.createElement(\"head\", null, /*#__PURE__*/React__default.createElement(\"meta\", {\n    charSet: \"utf-8\"\n  }), /*#__PURE__*/React__default.createElement(\"meta\", {\n    name: \"viewport\",\n    content: \"width=device-width,initial-scale=1,viewport-fit=cover\"\n  }), /*#__PURE__*/React__default.createElement(\"title\", null, \"Application Error!\")), /*#__PURE__*/React__default.createElement(\"body\", null, /*#__PURE__*/React__default.createElement(\"main\", {\n    style: {\n      fontFamily: \"system-ui, sans-serif\",\n      padding: \"2rem\"\n    }\n  }, /*#__PURE__*/React__default.createElement(\"h1\", {\n    style: {\n      fontSize: \"24px\"\n    }\n  }, \"Application Error\"), /*#__PURE__*/React__default.createElement(\"pre\", {\n    style: {\n      padding: \"2rem\",\n      background: \"hsla(10, 50%, 50%, 0.1)\",\n      color: \"red\",\n      overflow: \"auto\"\n    }\n  }, error.stack)), /*#__PURE__*/React__default.createElement(\"script\", {\n    dangerouslySetInnerHTML: {\n      __html: `\n              console.log(\n                \"\uD83D\uDCBF Hey developer\uD83D\uDC4B. You can provide a way better UX than this when your app throws errors. Check out https://remix.run/guides/errors for more information.\"\n              );\n            `\n    }\n  })));\n}\nlet RemixCatchContext = /*#__PURE__*/React__default.createContext(undefined);\n/**\n * Returns the status code and thrown response data.\n *\n * @see https://remix.run/api/conventions#catchboundary\n */\n\nfunction useCatch() {\n  return useContext(RemixCatchContext);\n}\nfunction RemixCatchBoundary({\n  catch: catchVal,\n  component: Component,\n  children\n}) {\n  if (catchVal) {\n    return /*#__PURE__*/React__default.createElement(RemixCatchContext.Provider, {\n      value: catchVal\n    }, /*#__PURE__*/React__default.createElement(Component, null));\n  }\n\n  return /*#__PURE__*/React__default.createElement(React__default.Fragment, null, children);\n}\n/**\n * When app's don't provide a root level CatchBoundary, we default to this.\n */\n\nfunction RemixRootDefaultCatchBoundary() {\n  let caught = useCatch();\n  return /*#__PURE__*/React__default.createElement(\"html\", {\n    lang: \"en\"\n  }, /*#__PURE__*/React__default.createElement(\"head\", null, /*#__PURE__*/React__default.createElement(\"meta\", {\n    charSet: \"utf-8\"\n  }), /*#__PURE__*/React__default.createElement(\"meta\", {\n    name: \"viewport\",\n    content: \"width=device-width,initial-scale=1,viewport-fit=cover\"\n  }), /*#__PURE__*/React__default.createElement(\"title\", null, \"Unhandled Thrown Response!\")), /*#__PURE__*/React__default.createElement(\"body\", null, /*#__PURE__*/React__default.createElement(\"h1\", {\n    style: {\n      fontFamily: \"system-ui, sans-serif\",\n      padding: \"2rem\"\n    }\n  }, caught.status, \" \", caught.statusText), /*#__PURE__*/React__default.createElement(\"script\", {\n    dangerouslySetInnerHTML: {\n      __html: `\n              console.log(\n                \"\uD83D\uDCBF Hey developer\uD83D\uDC4B. You can provide a way better UX than this when your app throws 404s (and other responses). Check out https://remix.run/guides/not-found for more information.\"\n              );\n            `\n    }\n  })));\n}\n\nexport { RemixCatchBoundary, RemixErrorBoundary, RemixRootDefaultCatchBoundary, RemixRootDefaultErrorBoundary, useCatch };\n", "/**\n * @remix-run/react v1.3.3\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\nfunction invariant(value, message) {\n  if (value === false || value === null || typeof value === \"undefined\") {\n    throw new Error(message);\n  }\n}\n\nexport { invariant as default };\n", "/**\n * @remix-run/react v1.3.3\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\nimport { parsePath } from 'history';\nimport { loadRouteModule } from './routeModules.js';\n\n// TODO: We eventually might not want to import anything directly from `history`\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * Gets all the links for a set of matches. The modules are assumed to have been\n * loaded already.\n */\nfunction getLinksForMatches(matches, routeModules, manifest) {\n  let descriptors = matches.map(match => {\n    var _module$links;\n\n    let module = routeModules[match.route.id];\n    return ((_module$links = module.links) === null || _module$links === void 0 ? void 0 : _module$links.call(module)) || [];\n  }).flat(1);\n  let preloads = getCurrentPageModulePreloadHrefs(matches, manifest);\n  return dedupe(descriptors, preloads);\n}\nasync function prefetchStyleLinks(routeModule) {\n  if (!routeModule.links) return;\n  let descriptors = routeModule.links();\n  if (!descriptors) return;\n  let styleLinks = [];\n\n  for (let descriptor of descriptors) {\n    if (!isPageLinkDescriptor(descriptor) && descriptor.rel === \"stylesheet\") {\n      styleLinks.push({ ...descriptor,\n        rel: \"preload\",\n        as: \"style\"\n      });\n    }\n  } // don't block for non-matching media queries\n\n\n  let matchingLinks = styleLinks.filter(link => !link.media || window.matchMedia(link.media).matches);\n  await Promise.all(matchingLinks.map(prefetchStyleLink));\n}\n\nasync function prefetchStyleLink(descriptor) {\n  return new Promise(resolve => {\n    let link = document.createElement(\"link\");\n    Object.assign(link, descriptor);\n\n    function removeLink() {\n      // if a navigation interrupts this prefetch React will update the <head>\n      // and remove the link we put in there manually, so we check if it's still\n      // there before trying to remove it\n      if (document.head.contains(link)) {\n        document.head.removeChild(link);\n      }\n    }\n\n    link.onload = () => {\n      removeLink();\n      resolve();\n    };\n\n    link.onerror = () => {\n      removeLink();\n      resolve();\n    };\n\n    document.head.appendChild(link);\n  });\n} ////////////////////////////////////////////////////////////////////////////////\n\n\nfunction isPageLinkDescriptor(object) {\n  return object != null && typeof object.page === \"string\";\n}\nfunction isHtmlLinkDescriptor(object) {\n  return object != null && typeof object.rel === \"string\" && typeof object.href === \"string\";\n}\nasync function getStylesheetPrefetchLinks(matches, routeModules) {\n  let links = await Promise.all(matches.map(async match => {\n    let mod = await loadRouteModule(match.route, routeModules);\n    return mod.links ? mod.links() : [];\n  }));\n  return links.flat(1).filter(isHtmlLinkDescriptor).filter(link => link.rel === \"stylesheet\" || link.rel === \"preload\").map(({\n    rel,\n    ...attrs\n  }) => rel === \"preload\" ? {\n    rel: \"prefetch\",\n    ...attrs\n  } : {\n    rel: \"prefetch\",\n    as: \"style\",\n    ...attrs\n  });\n} // This is ridiculously identical to transition.ts `filterMatchesToLoad`\n\nfunction getNewMatchesForLinks(page, nextMatches, currentMatches, location, mode) {\n  let path = parsePathPatch(page);\n\n  let isNew = (match, index) => {\n    if (!currentMatches[index]) return true;\n    return match.route.id !== currentMatches[index].route.id;\n  };\n\n  let matchPathChanged = (match, index) => {\n    var _currentMatches$index;\n\n    return (// param change, /users/123 -> /users/456\n      currentMatches[index].pathname !== match.pathname || // splat param changed, which is not present in match.path\n      // e.g. /files/images/avatar.jpg -> files/finances.xls\n      ((_currentMatches$index = currentMatches[index].route.path) === null || _currentMatches$index === void 0 ? void 0 : _currentMatches$index.endsWith(\"*\")) && currentMatches[index].params[\"*\"] !== match.params[\"*\"]\n    );\n  }; // NOTE: keep this mostly up-to-date w/ the transition data diff, but this\n  // version doesn't care about submissions\n\n\n  let newMatches = mode === \"data\" && location.search !== path.search ? // this is really similar to stuff in transition.ts, maybe somebody smarter\n  // than me (or in less of a hurry) can share some of it. You're the best.\n  nextMatches.filter((match, index) => {\n    if (!match.route.hasLoader) {\n      return false;\n    }\n\n    if (isNew(match, index) || matchPathChanged(match, index)) {\n      return true;\n    }\n\n    if (match.route.shouldReload) {\n      return match.route.shouldReload({\n        params: match.params,\n        prevUrl: new URL(location.pathname + location.search + location.hash, window.origin),\n        url: new URL(page, window.origin)\n      });\n    }\n\n    return true;\n  }) : nextMatches.filter((match, index) => {\n    return (mode === \"assets\" || match.route.hasLoader) && (isNew(match, index) || matchPathChanged(match, index));\n  });\n  return newMatches;\n}\nfunction getDataLinkHrefs(page, matches, manifest) {\n  let path = parsePathPatch(page);\n  return dedupeHrefs(matches.filter(match => manifest.routes[match.route.id].hasLoader).map(match => {\n    let {\n      pathname,\n      search\n    } = path;\n    let searchParams = new URLSearchParams(search);\n    searchParams.set(\"_data\", match.route.id);\n    return `${pathname}?${searchParams}`;\n  }));\n}\nfunction getModuleLinkHrefs(matches, manifestPatch) {\n  return dedupeHrefs(matches.map(match => {\n    let route = manifestPatch.routes[match.route.id];\n    let hrefs = [route.module];\n\n    if (route.imports) {\n      hrefs = hrefs.concat(route.imports);\n    }\n\n    return hrefs;\n  }).flat(1));\n} // The `<Script>` will render rel=modulepreload for the current page, we don't\n// need to include them in a page prefetch, this gives us the list to remove\n// while deduping.\n\nfunction getCurrentPageModulePreloadHrefs(matches, manifest) {\n  return dedupeHrefs(matches.map(match => {\n    let route = manifest.routes[match.route.id];\n    let hrefs = [route.module];\n\n    if (route.imports) {\n      hrefs = hrefs.concat(route.imports);\n    }\n\n    return hrefs;\n  }).flat(1));\n}\n\nfunction dedupeHrefs(hrefs) {\n  return [...new Set(hrefs)];\n}\n\nfunction dedupe(descriptors, preloads) {\n  let set = new Set();\n  let preloadsSet = new Set(preloads);\n  return descriptors.reduce((deduped, descriptor) => {\n    let alreadyModulePreload = !isPageLinkDescriptor(descriptor) && descriptor.as === \"script\" && descriptor.href && preloadsSet.has(descriptor.href);\n\n    if (alreadyModulePreload) {\n      return deduped;\n    }\n\n    let str = JSON.stringify(descriptor);\n\n    if (!set.has(str)) {\n      set.add(str);\n      deduped.push(descriptor);\n    }\n\n    return deduped;\n  }, []);\n} // https://github.com/remix-run/history/issues/897\n\nfunction parsePathPatch(href) {\n  let path = parsePath(href);\n  if (path.search === undefined) path.search = \"\";\n  return path;\n}\n\nexport { dedupe, getDataLinkHrefs, getLinksForMatches, getModuleLinkHrefs, getNewMatchesForLinks, getStylesheetPrefetchLinks, isHtmlLinkDescriptor, isPageLinkDescriptor, prefetchStyleLinks };\n", "/**\n * @remix-run/react v1.3.3\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\n// TODO: We eventually might not want to import anything directly from `history`\n// and leverage `react-router` here instead\n// TODO: import/export from react-router-dom\n\n/**\n * A React component that is rendered when the server throws a Response.\n *\n * @see https://remix.run/api/conventions#catchboundary\n */\n\n/**\n * A React component that is rendered when there is an error on a route.\n *\n * @see https://remix.run/api/conventions#errorboundary\n */\n\n/**\n * A function that defines `<link>` tags to be inserted into the `<head>` of\n * the document on route transitions.\n *\n * @see https://remix.run/api/remix#meta-links-scripts\n */\n\n/**\n * A function that returns an object of name + content pairs to use for\n * `<meta>` tags for a route. These tags will be merged with (and take\n * precedence over) tags from parent routes.\n *\n * @see https://remix.run/api/remix#meta-links-scripts\n */\n\n/**\n * A name/content pair used to render `<meta>` tags in a meta function for a\n * route. The value can be either a string, which will render a single `<meta>`\n * tag, or an array of strings that will render multiple tags with the same\n * `name` attribute.\n */\n\n/**\n * During client side transitions Remix will optimize reloading of routes that\n * are currently on the page by avoiding loading routes that aren't changing.\n * However, in some cases, like form submissions or search params Remix doesn't\n * know which routes need to be reloaded so it reloads them all to be safe.\n *\n * This function lets apps further optimize by returning `false` when Remix is\n * about to reload the route. A common case is a root loader with nothing but\n * environment variables: after form submissions the root probably doesn't need\n * to be reloaded.\n *\n * @see https://remix.run/api/conventions#unstable_shouldreload\n */\n\n/**\n * A React component that is rendered for a route.\n */\n\n/**\n * An arbitrary object that is associated with a route.\n *\n * @see https://remix.run/api/conventions#handle\n */\nasync function loadRouteModule(route, routeModulesCache) {\n  if (route.id in routeModulesCache) {\n    return routeModulesCache[route.id];\n  }\n\n  try {\n    let routeModule = await import(route.module);\n    routeModulesCache[route.id] = routeModule;\n    return routeModule;\n  } catch (error) {\n    // User got caught in the middle of a deploy and the CDN no longer has the\n    // asset we're trying to import! Reload from the server and the user\n    // (should) get the new manifest--unless the developer purged the static\n    // assets, the manifest path, but not the documents \uD83D\uDE2C\n    window.location.reload();\n    return new Promise(() => {// check out of this hook cause the DJs never gonna re[s]olve this\n    });\n  }\n}\n\nexport { loadRouteModule };\n", "/**\n * @remix-run/react v1.3.3\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\nfunction createHtml(html) {\n  return {\n    __html: html\n  };\n}\n\nexport { createHtml };\n", "/**\n * @remix-run/react v1.3.3\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\nimport * as React from 'react';\nimport { loadRouteModule } from './routeModules.js';\nimport { fetchData, isCatchResponse, extractData, isRedirectResponse } from './data.js';\nimport { CatchValue, TransitionRedirect } from './transition.js';\nimport { prefetchStyleLinks } from './links.js';\nimport invariant from './invariant.js';\n\nfunction createClientRoute(entryRoute, routeModulesCache, Component) {\n  return {\n    caseSensitive: !!entryRoute.caseSensitive,\n    element: /*#__PURE__*/React.createElement(Component, {\n      id: entryRoute.id\n    }),\n    id: entryRoute.id,\n    path: entryRoute.path,\n    index: entryRoute.index,\n    module: entryRoute.module,\n    loader: createLoader(entryRoute, routeModulesCache),\n    action: createAction(entryRoute, routeModulesCache),\n    shouldReload: createShouldReload(entryRoute, routeModulesCache),\n    ErrorBoundary: entryRoute.hasErrorBoundary,\n    CatchBoundary: entryRoute.hasCatchBoundary,\n    hasLoader: entryRoute.hasLoader\n  };\n}\nfunction createClientRoutes(routeManifest, routeModulesCache, Component, parentId) {\n  return Object.keys(routeManifest).filter(key => routeManifest[key].parentId === parentId).map(key => {\n    let route = createClientRoute(routeManifest[key], routeModulesCache, Component);\n    let children = createClientRoutes(routeManifest, routeModulesCache, Component, route.id);\n    if (children.length > 0) route.children = children;\n    return route;\n  });\n}\n\nfunction createShouldReload(route, routeModules) {\n  let shouldReload = arg => {\n    let module = routeModules[route.id];\n    invariant(module, `Expected route module to be loaded for ${route.id}`);\n\n    if (module.unstable_shouldReload) {\n      return module.unstable_shouldReload(arg);\n    }\n\n    return true;\n  };\n\n  return shouldReload;\n}\n\nasync function loadRouteModuleWithBlockingLinks(route, routeModules) {\n  let routeModule = await loadRouteModule(route, routeModules);\n  await prefetchStyleLinks(routeModule);\n  return routeModule;\n}\n\nfunction createLoader(route, routeModules) {\n  let loader = async ({\n    url,\n    signal,\n    submission\n  }) => {\n    if (route.hasLoader) {\n      let [result] = await Promise.all([fetchData(url, route.id, signal, submission), loadRouteModuleWithBlockingLinks(route, routeModules)]);\n      if (result instanceof Error) throw result;\n      let redirect = await checkRedirect(result);\n      if (redirect) return redirect;\n\n      if (isCatchResponse(result)) {\n        throw new CatchValue(result.status, result.statusText, await extractData(result.clone()));\n      }\n\n      return extractData(result);\n    } else {\n      await loadRouteModuleWithBlockingLinks(route, routeModules);\n    }\n  };\n\n  return loader;\n}\n\nfunction createAction(route, routeModules) {\n  let action = async ({\n    url,\n    signal,\n    submission\n  }) => {\n    if (!route.hasAction) {\n      console.error(`Route \"${route.id}\" does not have an action, but you are trying ` + `to submit to it. To fix this, please add an \\`action\\` function to the route`);\n    }\n\n    let result = await fetchData(url, route.id, signal, submission);\n\n    if (result instanceof Error) {\n      throw result;\n    }\n\n    let redirect = await checkRedirect(result);\n    if (redirect) return redirect;\n    await loadRouteModuleWithBlockingLinks(route, routeModules);\n\n    if (isCatchResponse(result)) {\n      throw new CatchValue(result.status, result.statusText, await extractData(result.clone()));\n    }\n\n    return extractData(result);\n  };\n\n  return action;\n}\n\nasync function checkRedirect(response) {\n  if (isRedirectResponse(response)) {\n    let url = new URL(response.headers.get(\"X-Remix-Redirect\"), window.location.origin);\n\n    if (url.origin !== window.location.origin) {\n      await new Promise(() => {\n        window.location.replace(url.href);\n      });\n    } else {\n      return new TransitionRedirect(url.pathname + url.search, response.headers.get(\"X-Remix-Revalidate\") !== null);\n    }\n  }\n\n  return null;\n}\n\nexport { createClientRoute, createClientRoutes };\n", "/**\n * @remix-run/react v1.3.3\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\nimport invariant from './invariant.js';\n\nfunction isCatchResponse(response) {\n  return response instanceof Response && response.headers.get(\"X-Remix-Catch\") != null;\n}\nfunction isErrorResponse(response) {\n  return response instanceof Response && response.headers.get(\"X-Remix-Error\") != null;\n}\nfunction isRedirectResponse(response) {\n  return response instanceof Response && response.headers.get(\"X-Remix-Redirect\") != null;\n}\nasync function fetchData(url, routeId, signal, submission) {\n  url.searchParams.set(\"_data\", routeId);\n  let init = submission ? getActionInit(submission, signal) : {\n    credentials: \"same-origin\",\n    signal\n  };\n  let response = await fetch(url.href, init);\n\n  if (isErrorResponse(response)) {\n    let data = await response.json();\n    let error = new Error(data.message);\n    error.stack = data.stack;\n    return error;\n  }\n\n  return response;\n}\nasync function extractData(response) {\n  // This same algorithm is used on the server to interpret load\n  // results when we render the HTML page.\n  let contentType = response.headers.get(\"Content-Type\");\n\n  if (contentType && /\\bapplication\\/json\\b/.test(contentType)) {\n    return response.json();\n  }\n\n  return response.text();\n}\n\nfunction getActionInit(submission, signal) {\n  let {\n    encType,\n    method,\n    formData\n  } = submission;\n  let headers = undefined;\n  let body = formData;\n\n  if (encType === \"application/x-www-form-urlencoded\") {\n    body = new URLSearchParams();\n\n    for (let [key, value] of formData) {\n      invariant(typeof value === \"string\", `File inputs are not supported with encType \"application/x-www-form-urlencoded\", please use \"multipart/form-data\" instead.`);\n      body.append(key, value);\n    }\n\n    headers = {\n      \"Content-Type\": encType\n    };\n  }\n\n  return {\n    method,\n    body,\n    signal,\n    credentials: \"same-origin\",\n    headers\n  };\n}\n\nexport { extractData, fetchData, isCatchResponse, isErrorResponse, isRedirectResponse };\n", "/**\n * @remix-run/react v1.3.3\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\nimport { Action } from 'history';\nimport { matchClientRoutes } from './routeMatching.js';\nimport invariant from './invariant.js';\n\n// TODO: We eventually might not want to import anything directly from `history`\n//#region Types and Utils\n////////////////////////////////////////////////////////////////////////////////\n\nclass CatchValue {\n  constructor(status, statusText, data) {\n    this.status = status;\n    this.statusText = statusText;\n    this.data = data;\n  }\n\n}\n\nfunction isActionSubmission(submission) {\n  return [\"POST\", \"PUT\", \"PATCH\", \"DELETE\"].includes(submission.method);\n}\n\nfunction isLoaderSubmission(submission) {\n  return submission.method === \"GET\";\n}\n\nfunction isRedirectLocation(location) {\n  return Boolean(location.state) && location.state.isRedirect;\n}\n\nfunction isLoaderRedirectLocation(location) {\n  return isRedirectLocation(location) && location.state.type === \"loader\";\n}\n\nfunction isActionRedirectLocation(location) {\n  return isRedirectLocation(location) && location.state.type === \"action\";\n}\n\nfunction isFetchActionRedirect(location) {\n  return isRedirectLocation(location) && location.state.type === \"fetchAction\";\n}\n\nfunction isLoaderSubmissionRedirectLocation(location) {\n  return isRedirectLocation(location) && location.state.type === \"loaderSubmission\";\n}\n\nclass TransitionRedirect {\n  constructor(location, setCookie) {\n    this.setCookie = setCookie;\n    this.location = typeof location === \"string\" ? location : location.pathname + location.search;\n  }\n\n}\nconst IDLE_TRANSITION = {\n  state: \"idle\",\n  submission: undefined,\n  location: undefined,\n  type: \"idle\"\n};\nconst IDLE_FETCHER = {\n  state: \"idle\",\n  type: \"init\",\n  data: undefined,\n  submission: undefined\n}; //#endregion\n////////////////////////////////////////////////////////////////////////////////\n//#region createTransitionManager\n////////////////////////////////////////////////////////////////////////////////\n\nfunction createTransitionManager(init) {\n  let {\n    routes\n  } = init;\n  let pendingNavigationController;\n  let fetchControllers = new Map();\n  let incrementingLoadId = 0;\n  let navigationLoadId = -1;\n  let fetchReloadIds = new Map();\n  let fetchRedirectIds = new Set();\n  let matches = matchClientRoutes(routes, init.location);\n\n  if (!matches) {\n    // If we do not match a user-provided-route, fall back to the root\n    // to allow the CatchBoundary to take over\n    matches = [{\n      params: {},\n      pathname: \"\",\n      route: routes[0]\n    }];\n  }\n\n  let state = {\n    location: init.location,\n    loaderData: init.loaderData || {},\n    actionData: init.actionData,\n    catch: init.catch,\n    error: init.error,\n    catchBoundaryId: init.catchBoundaryId || null,\n    errorBoundaryId: init.errorBoundaryId || null,\n    matches,\n    nextMatches: undefined,\n    transition: IDLE_TRANSITION,\n    fetchers: new Map()\n  };\n\n  function update(updates) {\n    if (updates.transition) {\n      if (updates.transition === IDLE_TRANSITION) {\n        pendingNavigationController = undefined;\n      }\n    }\n\n    state = Object.assign({}, state, updates);\n    init.onChange(state);\n  }\n\n  function getState() {\n    return state;\n  }\n\n  function getFetcher(key) {\n    return state.fetchers.get(key) || IDLE_FETCHER;\n  }\n\n  function setFetcher(key, fetcher) {\n    state.fetchers.set(key, fetcher);\n  }\n\n  function deleteFetcher(key) {\n    if (fetchControllers.has(key)) abortFetcher(key);\n    fetchReloadIds.delete(key);\n    fetchRedirectIds.delete(key);\n    state.fetchers.delete(key);\n  }\n\n  async function send(event) {\n    switch (event.type) {\n      case \"navigation\":\n        {\n          let {\n            action,\n            location,\n            submission\n          } = event;\n          let matches = matchClientRoutes(routes, location);\n\n          if (!matches) {\n            matches = [{\n              params: {},\n              pathname: \"\",\n              route: routes[0]\n            }];\n            await handleNotFoundNavigation(location, matches);\n          } else if (!submission && isHashChangeOnly(location)) {\n            await handleHashChange(location, matches);\n          } // back/forward button, treat all as normal navigation\n          else if (action === Action.Pop) {\n            await handleLoad(location, matches);\n          } // <Form method=\"post | put | delete | patch\">\n          else if (submission && isActionSubmission(submission)) {\n            await handleActionSubmissionNavigation(location, submission, matches);\n          } // <Form method=\"get\"/>\n          else if (submission && isLoaderSubmission(submission)) {\n            await handleLoaderSubmissionNavigation(location, submission, matches);\n          } // action=>redirect\n          else if (isActionRedirectLocation(location)) {\n            await handleActionRedirect(location, matches);\n          } // <Form method=\"get\"> --> loader=>redirect\n          else if (isLoaderSubmissionRedirectLocation(location)) {\n            await handleLoaderSubmissionRedirect(location, matches);\n          } // loader=>redirect\n          else if (isLoaderRedirectLocation(location)) {\n            await handleLoaderRedirect(location, matches);\n          } // useSubmission()=>redirect\n          else if (isFetchActionRedirect(location)) {\n            await handleFetchActionRedirect(location, matches);\n          } // <Link>, navigate()\n          else {\n            await handleLoad(location, matches);\n          }\n\n          navigationLoadId = -1;\n          break;\n        }\n\n      case \"fetcher\":\n        {\n          let {\n            key,\n            submission,\n            href\n          } = event;\n          let matches = matchClientRoutes(routes, href);\n          invariant(matches, \"No matches found\");\n          if (fetchControllers.has(key)) abortFetcher(key);\n          let match = getFetcherRequestMatch(new URL(href, window.location.href), matches);\n\n          if (submission && isActionSubmission(submission)) {\n            await handleActionFetchSubmission(key, submission, match);\n          } else if (submission && isLoaderSubmission(submission)) {\n            await handleLoaderFetchSubmission(href, key, submission, match);\n          } else {\n            await handleLoaderFetch(href, key, match);\n          }\n\n          break;\n        }\n\n      default:\n        {\n          // @ts-ignore\n          throw new Error(`Unknown data event type: ${event.type}`);\n        }\n    }\n  }\n\n  function dispose() {\n    abortNormalNavigation();\n\n    for (let [, controller] of fetchControllers) {\n      controller.abort();\n    }\n  }\n\n  function isIndexRequestUrl(url) {\n    for (let param of url.searchParams.getAll(\"index\")) {\n      // only use bare `?index` params without a value\n      // \u2705 /foo?index\n      // \u2705 /foo?index&index=123\n      // \u2705 /foo?index=123&index\n      // \u274C /foo?index=123\n      if (param === \"\") {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  function getFetcherRequestMatch(url, matches) {\n    let match = matches.slice(-1)[0];\n\n    if (!isIndexRequestUrl(url) && match.route.id.endsWith(\"/index\")) {\n      return matches.slice(-2)[0];\n    }\n\n    return match;\n  }\n\n  async function handleActionFetchSubmission(key, submission, match) {\n    let currentFetcher = state.fetchers.get(key);\n    let fetcher = {\n      state: \"submitting\",\n      type: \"actionSubmission\",\n      submission,\n      data: (currentFetcher === null || currentFetcher === void 0 ? void 0 : currentFetcher.data) || undefined\n    };\n    setFetcher(key, fetcher);\n    update({\n      fetchers: new Map(state.fetchers)\n    });\n    let controller = new AbortController();\n    fetchControllers.set(key, controller);\n    let result = await callAction(submission, match, controller.signal);\n\n    if (controller.signal.aborted) {\n      return;\n    }\n\n    if (isRedirectResult(result)) {\n      let locationState = {\n        isRedirect: true,\n        type: \"fetchAction\",\n        setCookie: result.value.setCookie\n      };\n      fetchRedirectIds.add(key);\n      init.onRedirect(result.value.location, locationState);\n      let loadingFetcher = {\n        state: \"loading\",\n        type: \"actionRedirect\",\n        submission,\n        data: undefined\n      };\n      setFetcher(key, loadingFetcher);\n      update({\n        fetchers: new Map(state.fetchers)\n      });\n      return;\n    }\n\n    if (maybeBailOnError(match, key, result)) {\n      return;\n    }\n\n    if (await maybeBailOnCatch(match, key, result)) {\n      return;\n    }\n\n    let loadFetcher = {\n      state: \"loading\",\n      type: \"actionReload\",\n      data: result.value,\n      submission\n    };\n    setFetcher(key, loadFetcher);\n    update({\n      fetchers: new Map(state.fetchers)\n    });\n    let maybeActionErrorResult = isErrorResult(result) ? result : undefined;\n    let maybeActionCatchResult = isCatchResult(result) ? result : undefined;\n    let loadId = ++incrementingLoadId;\n    fetchReloadIds.set(key, loadId);\n    let matchesToLoad = state.nextMatches || state.matches;\n    let results = await callLoaders(state, state.transition.location || state.location, matchesToLoad, controller.signal, maybeActionErrorResult, maybeActionCatchResult, submission, match.route.id, loadFetcher);\n\n    if (controller.signal.aborted) {\n      return;\n    }\n\n    fetchReloadIds.delete(key);\n    fetchControllers.delete(key);\n    let redirect = findRedirect(results);\n\n    if (redirect) {\n      let locationState = {\n        isRedirect: true,\n        type: \"loader\",\n        setCookie: redirect.setCookie\n      };\n      init.onRedirect(redirect.location, locationState);\n      return;\n    }\n\n    let [error, errorBoundaryId] = findErrorAndBoundaryId(results, state.matches, maybeActionErrorResult);\n    let [catchVal, catchBoundaryId] = (await findCatchAndBoundaryId(results, state.matches, maybeActionCatchResult)) || [];\n    let doneFetcher = {\n      state: \"idle\",\n      type: \"done\",\n      data: result.value,\n      submission: undefined\n    };\n    setFetcher(key, doneFetcher);\n    let abortedKeys = abortStaleFetchLoads(loadId);\n\n    if (abortedKeys) {\n      markFetchersDone(abortedKeys);\n    }\n\n    let yeetedNavigation = yeetStaleNavigationLoad(loadId); // need to do what we would have done when the navigation load completed\n\n    if (yeetedNavigation) {\n      let {\n        transition\n      } = state;\n      invariant(transition.state === \"loading\", \"Expected loading transition\");\n      update({\n        location: transition.location,\n        matches: state.nextMatches,\n        error,\n        errorBoundaryId,\n        catch: catchVal,\n        catchBoundaryId,\n        loaderData: makeLoaderData(state, results, matchesToLoad),\n        actionData: transition.type === \"actionReload\" ? state.actionData : undefined,\n        transition: IDLE_TRANSITION,\n        fetchers: new Map(state.fetchers)\n      });\n    } // otherwise just update the info for the data\n    else {\n      update({\n        fetchers: new Map(state.fetchers),\n        error,\n        errorBoundaryId,\n        loaderData: makeLoaderData(state, results, matchesToLoad)\n      });\n    }\n  }\n\n  function yeetStaleNavigationLoad(landedId) {\n    let isLoadingNavigation = state.transition.state === \"loading\";\n\n    if (isLoadingNavigation && navigationLoadId < landedId) {\n      abortNormalNavigation();\n      return true;\n    }\n\n    return false;\n  }\n\n  function markFetchersDone(keys) {\n    for (let key of keys) {\n      let fetcher = getFetcher(key);\n      let doneFetcher = {\n        state: \"idle\",\n        type: \"done\",\n        data: fetcher.data,\n        submission: undefined\n      };\n      setFetcher(key, doneFetcher);\n    }\n  }\n\n  function abortStaleFetchLoads(landedId) {\n    let yeetedKeys = [];\n\n    for (let [key, id] of fetchReloadIds) {\n      if (id < landedId) {\n        let fetcher = state.fetchers.get(key);\n        invariant(fetcher, `Expected fetcher: ${key}`);\n\n        if (fetcher.state === \"loading\") {\n          abortFetcher(key);\n          fetchReloadIds.delete(key);\n          yeetedKeys.push(key);\n        }\n      }\n    }\n\n    return yeetedKeys.length ? yeetedKeys : false;\n  }\n\n  async function handleLoaderFetchSubmission(href, key, submission, match) {\n    let currentFetcher = state.fetchers.get(key);\n    let fetcher = {\n      state: \"submitting\",\n      type: \"loaderSubmission\",\n      submission,\n      data: (currentFetcher === null || currentFetcher === void 0 ? void 0 : currentFetcher.data) || undefined\n    };\n    setFetcher(key, fetcher);\n    update({\n      fetchers: new Map(state.fetchers)\n    });\n    let controller = new AbortController();\n    fetchControllers.set(key, controller);\n    let result = await callLoader(match, createUrl(href), controller.signal);\n    fetchControllers.delete(key);\n\n    if (controller.signal.aborted) {\n      return;\n    }\n\n    if (isRedirectResult(result)) {\n      let locationState = {\n        isRedirect: true,\n        type: \"loader\",\n        setCookie: result.value.setCookie\n      };\n      init.onRedirect(result.value.location, locationState);\n      return;\n    }\n\n    if (maybeBailOnError(match, key, result)) {\n      return;\n    }\n\n    if (await maybeBailOnCatch(match, key, result)) {\n      return;\n    }\n\n    let doneFetcher = {\n      state: \"idle\",\n      type: \"done\",\n      data: result.value,\n      submission: undefined\n    };\n    setFetcher(key, doneFetcher);\n    update({\n      fetchers: new Map(state.fetchers)\n    });\n  }\n\n  async function handleLoaderFetch(href, key, match) {\n    if (typeof AbortController === \"undefined\") {\n      throw new Error(\"handleLoaderFetch was called during the server render, but it shouldn't be. \" + \"You are likely calling useFetcher.load() in the body of your component. \" + \"Try moving it to a useEffect or a callback.\");\n    }\n\n    let currentFetcher = state.fetchers.get(key);\n    let fetcher = {\n      state: \"loading\",\n      type: \"normalLoad\",\n      submission: undefined,\n      data: (currentFetcher === null || currentFetcher === void 0 ? void 0 : currentFetcher.data) || undefined\n    };\n    setFetcher(key, fetcher);\n    update({\n      fetchers: new Map(state.fetchers)\n    });\n    let controller = new AbortController();\n    fetchControllers.set(key, controller);\n    let result = await callLoader(match, createUrl(href), controller.signal);\n    if (controller.signal.aborted) return;\n    fetchControllers.delete(key);\n\n    if (isRedirectResult(result)) {\n      let locationState = {\n        isRedirect: true,\n        type: \"loader\",\n        setCookie: result.value.setCookie\n      };\n      init.onRedirect(result.value.location, locationState);\n      return;\n    }\n\n    if (maybeBailOnError(match, key, result)) {\n      return;\n    }\n\n    if (await maybeBailOnCatch(match, key, result)) {\n      return;\n    }\n\n    let doneFetcher = {\n      state: \"idle\",\n      type: \"done\",\n      data: result.value,\n      submission: undefined\n    };\n    setFetcher(key, doneFetcher);\n    update({\n      fetchers: new Map(state.fetchers)\n    });\n  }\n\n  async function maybeBailOnCatch(match, key, result) {\n    // TODO: revisit this if submission is correct after review\n    if (isCatchResult(result)) {\n      let catchBoundaryId = findNearestCatchBoundary(match, state.matches);\n      state.fetchers.delete(key);\n      update({\n        transition: IDLE_TRANSITION,\n        fetchers: new Map(state.fetchers),\n        catch: {\n          data: result.value.data,\n          status: result.value.status,\n          statusText: result.value.statusText\n        },\n        catchBoundaryId\n      });\n      return true;\n    }\n\n    return false;\n  }\n\n  function maybeBailOnError(match, key, result) {\n    if (isErrorResult(result)) {\n      let errorBoundaryId = findNearestBoundary(match, state.matches);\n      state.fetchers.delete(key);\n      update({\n        fetchers: new Map(state.fetchers),\n        error: result.value,\n        errorBoundaryId\n      });\n      return true;\n    }\n\n    return false;\n  }\n\n  async function handleNotFoundNavigation(location, matches) {\n    abortNormalNavigation();\n    let transition = {\n      state: \"loading\",\n      type: \"normalLoad\",\n      submission: undefined,\n      location\n    };\n    update({\n      transition,\n      nextMatches: matches\n    }); // Force async so UI code doesn't have to special not found route changes not\n    // skipping the pending state (like scroll restoration gets really\n    // complicated without the pending state, maybe we can figure something else\n    // out later, but this works great.)\n\n    await Promise.resolve();\n    let catchBoundaryId = findNearestCatchBoundary(matches[0], matches);\n    update({\n      location,\n      matches,\n      catch: {\n        data: null,\n        status: 404,\n        statusText: \"Not Found\"\n      },\n      catchBoundaryId,\n      transition: IDLE_TRANSITION\n    });\n  }\n\n  async function handleActionSubmissionNavigation(location, submission, matches) {\n    abortNormalNavigation();\n    let transition = {\n      state: \"submitting\",\n      type: \"actionSubmission\",\n      submission,\n      location\n    };\n    update({\n      transition,\n      nextMatches: matches\n    });\n    let controller = new AbortController();\n    pendingNavigationController = controller;\n\n    if (!isIndexRequestAction(submission.action) && matches[matches.length - 1].route.id.endsWith(\"/index\")) {\n      matches = matches.slice(0, -1);\n    }\n\n    let leafMatch = matches.slice(-1)[0];\n    let result = await callAction(submission, leafMatch, controller.signal);\n\n    if (controller.signal.aborted) {\n      return;\n    }\n\n    if (isRedirectResult(result)) {\n      let locationState = {\n        isRedirect: true,\n        type: \"action\",\n        setCookie: result.value.setCookie\n      };\n      init.onRedirect(result.value.location, locationState);\n      return;\n    }\n\n    let catchVal, catchBoundaryId;\n\n    if (isCatchResult(result)) {\n      [catchVal, catchBoundaryId] = (await findCatchAndBoundaryId([result], matches, result)) || [];\n    }\n\n    let loadTransition = {\n      state: \"loading\",\n      type: \"actionReload\",\n      submission,\n      location\n    };\n    update({\n      transition: loadTransition,\n      actionData: {\n        [leafMatch.route.id]: result.value\n      }\n    });\n    await loadPageData(location, matches, submission, leafMatch.route.id, result, catchVal, catchBoundaryId);\n  }\n\n  async function handleLoaderSubmissionNavigation(location, submission, matches) {\n    abortNormalNavigation();\n    let transition = {\n      state: \"submitting\",\n      type: \"loaderSubmission\",\n      submission,\n      location\n    };\n    update({\n      transition,\n      nextMatches: matches\n    });\n    await loadPageData(location, matches, submission);\n  }\n\n  async function handleHashChange(location, matches) {\n    abortNormalNavigation();\n    let transition = {\n      state: \"loading\",\n      type: \"normalLoad\",\n      submission: undefined,\n      location\n    };\n    update({\n      transition,\n      nextMatches: matches\n    }); // Force async so UI code doesn't have to special case hash changes not\n    // skipping the pending state (like scroll restoration gets really\n    // complicated without the pending state, maybe we can figure something else\n    // out later, but this works great.)\n\n    await Promise.resolve();\n    update({\n      location,\n      matches,\n      transition: IDLE_TRANSITION\n    });\n  }\n\n  async function handleLoad(location, matches) {\n    abortNormalNavigation();\n    let transition = {\n      state: \"loading\",\n      type: \"normalLoad\",\n      submission: undefined,\n      location\n    };\n    update({\n      transition,\n      nextMatches: matches\n    });\n    await loadPageData(location, matches);\n  }\n\n  async function handleLoaderRedirect(location, matches) {\n    abortNormalNavigation();\n    let transition = {\n      state: \"loading\",\n      type: \"normalRedirect\",\n      submission: undefined,\n      location\n    };\n    update({\n      transition,\n      nextMatches: matches\n    });\n    await loadPageData(location, matches);\n  }\n\n  async function handleLoaderSubmissionRedirect(location, matches) {\n    abortNormalNavigation();\n    invariant(state.transition.type === \"loaderSubmission\", `Unexpected transition: ${JSON.stringify(state.transition)}`);\n    let {\n      submission\n    } = state.transition;\n    let transition = {\n      state: \"loading\",\n      type: \"loaderSubmissionRedirect\",\n      submission,\n      location: location\n    };\n    update({\n      transition,\n      nextMatches: matches\n    });\n    await loadPageData(location, matches, submission);\n  }\n\n  async function handleFetchActionRedirect(location, matches) {\n    abortNormalNavigation();\n    let transition = {\n      state: \"loading\",\n      type: \"fetchActionRedirect\",\n      submission: undefined,\n      location\n    };\n    update({\n      transition,\n      nextMatches: matches\n    });\n    await loadPageData(location, matches);\n  }\n\n  async function handleActionRedirect(location, matches) {\n    abortNormalNavigation();\n    invariant(state.transition.type === \"actionSubmission\" || // loader redirected during action reload\n    state.transition.type === \"actionReload\", `Unexpected transition: ${JSON.stringify(state.transition)}`);\n    let {\n      submission\n    } = state.transition;\n    let transition = {\n      state: \"loading\",\n      type: \"actionRedirect\",\n      submission,\n      location\n    };\n    update({\n      transition,\n      nextMatches: matches\n    });\n    await loadPageData(location, matches, submission);\n  }\n\n  function isHashChangeOnly(location) {\n    return createHref(state.location) === createHref(location) && state.location.hash !== location.hash;\n  }\n\n  async function loadPageData(location, matches, submission, submissionRouteId, actionResult, catchVal, catchBoundaryId) {\n    let maybeActionErrorResult = actionResult && isErrorResult(actionResult) ? actionResult : undefined;\n    let maybeActionCatchResult = actionResult && isCatchResult(actionResult) ? actionResult : undefined;\n    let controller = new AbortController();\n    pendingNavigationController = controller;\n    navigationLoadId = ++incrementingLoadId;\n    let results = await callLoaders(state, location, matches, controller.signal, maybeActionErrorResult, maybeActionCatchResult, submission, submissionRouteId, undefined, catchBoundaryId);\n\n    if (controller.signal.aborted) {\n      return;\n    }\n\n    let redirect = findRedirect(results);\n\n    if (redirect) {\n      // loader redirected during an action reload, treat it like an\n      // actionRedirect instead so that all the loaders get called again and the\n      // submission sticks around for optimistic/pending UI.\n      if (state.transition.type === \"actionReload\") {\n        let locationState = {\n          isRedirect: true,\n          type: \"action\",\n          setCookie: redirect.setCookie\n        };\n        init.onRedirect(redirect.location, locationState);\n      } else if (state.transition.type === \"loaderSubmission\") {\n        let locationState = {\n          isRedirect: true,\n          type: \"loaderSubmission\",\n          setCookie: redirect.setCookie\n        };\n        init.onRedirect(redirect.location, locationState);\n      } else {\n        let locationState = {\n          isRedirect: true,\n          type: \"loader\",\n          setCookie: redirect.setCookie\n        };\n        init.onRedirect(redirect.location, locationState);\n      }\n\n      return;\n    }\n\n    let [error, errorBoundaryId] = findErrorAndBoundaryId(results, matches, maybeActionErrorResult);\n    [catchVal, catchBoundaryId] = (await findCatchAndBoundaryId(results, matches, maybeActionErrorResult)) || [catchVal, catchBoundaryId];\n    markFetchRedirectsDone();\n    let abortedIds = abortStaleFetchLoads(navigationLoadId);\n\n    if (abortedIds) {\n      markFetchersDone(abortedIds);\n    }\n\n    update({\n      location,\n      matches,\n      error,\n      errorBoundaryId,\n      catch: catchVal,\n      catchBoundaryId,\n      loaderData: makeLoaderData(state, results, matches),\n      actionData: state.transition.type === \"actionReload\" ? state.actionData : undefined,\n      transition: IDLE_TRANSITION,\n      fetchers: abortedIds ? new Map(state.fetchers) : state.fetchers\n    });\n  }\n\n  function abortNormalNavigation() {\n    if (pendingNavigationController) {\n      pendingNavigationController.abort();\n    }\n  }\n\n  function abortFetcher(key) {\n    let controller = fetchControllers.get(key);\n    invariant(controller, `Expected fetch controller: ${key}`);\n    controller.abort();\n    fetchControllers.delete(key);\n  }\n\n  function markFetchRedirectsDone() {\n    let doneKeys = [];\n\n    for (let key of fetchRedirectIds) {\n      let fetcher = state.fetchers.get(key);\n      invariant(fetcher, `Expected fetcher: ${key}`);\n\n      if (fetcher.type === \"actionRedirect\") {\n        fetchRedirectIds.delete(key);\n        doneKeys.push(key);\n      }\n    }\n\n    markFetchersDone(doneKeys);\n  }\n\n  return {\n    send,\n    getState,\n    getFetcher,\n    deleteFetcher,\n    dispose,\n\n    get _internalFetchControllers() {\n      return fetchControllers;\n    }\n\n  };\n} //#endregion\n////////////////////////////////////////////////////////////////////////////////\n//#region createTransitionManager sub-functions\n////////////////////////////////////////////////////////////////////////////////\n\nfunction isIndexRequestAction(action) {\n  let indexRequest = false;\n  let searchParams = new URLSearchParams(action.split(\"?\", 2)[1] || \"\");\n\n  for (let param of searchParams.getAll(\"index\")) {\n    if (!param) {\n      indexRequest = true;\n    }\n  }\n\n  return indexRequest;\n}\n\nasync function callLoaders(state, location, matches, signal, actionErrorResult, actionCatchResult, submission, submissionRouteId, fetcher, catchBoundaryId) {\n  let url = createUrl(createHref(location));\n  let matchesToLoad = filterMatchesToLoad(state, location, matches, actionErrorResult, actionCatchResult, submission, submissionRouteId, fetcher, catchBoundaryId);\n  return Promise.all(matchesToLoad.map(match => callLoader(match, url, signal)));\n}\n\nasync function callLoader(match, url, signal) {\n  invariant(match.route.loader, `Expected loader for ${match.route.id}`);\n\n  try {\n    let {\n      params\n    } = match;\n    let value = await match.route.loader({\n      params,\n      url,\n      signal\n    });\n    return {\n      match,\n      value\n    };\n  } catch (error) {\n    return {\n      match,\n      value: error\n    };\n  }\n}\n\nasync function callAction(submission, match, signal) {\n  try {\n    let value = await match.route.action({\n      url: createUrl(submission.action),\n      params: match.params,\n      submission,\n      signal\n    });\n    return {\n      match,\n      value\n    };\n  } catch (error) {\n    return {\n      match,\n      value: error\n    };\n  }\n}\n\nfunction filterMatchesToLoad(state, location, matches, actionErrorResult, actionCatchResult, submission, submissionRouteId, fetcher, catchBoundaryId) {\n  var _location$state;\n\n  // Filter out all routes below the problematic route as they aren't going\n  // to render so we don't need to load them.\n  if (catchBoundaryId || submissionRouteId && (actionCatchResult || actionErrorResult)) {\n    let foundProblematicRoute = false;\n    matches = matches.filter(match => {\n      if (foundProblematicRoute) {\n        return false;\n      }\n\n      if (match.route.id === submissionRouteId || match.route.id === catchBoundaryId) {\n        foundProblematicRoute = true;\n        return false;\n      }\n\n      return true;\n    });\n  }\n\n  let isNew = (match, index) => {\n    // [a] -> [a, b]\n    if (!state.matches[index]) return true; // [a, b] -> [a, c]\n\n    return match.route.id !== state.matches[index].route.id;\n  };\n\n  let matchPathChanged = (match, index) => {\n    var _state$matches$index$;\n\n    return (// param change, /users/123 -> /users/456\n      state.matches[index].pathname !== match.pathname || // splat param changed, which is not present in match.path\n      // e.g. /files/images/avatar.jpg -> files/finances.xls\n      ((_state$matches$index$ = state.matches[index].route.path) === null || _state$matches$index$ === void 0 ? void 0 : _state$matches$index$.endsWith(\"*\")) && state.matches[index].params[\"*\"] !== match.params[\"*\"]\n    );\n  };\n\n  let url = createUrl(createHref(location));\n\n  let filterByRouteProps = (match, index) => {\n    if (!match.route.loader) {\n      return false;\n    }\n\n    if (isNew(match, index) || matchPathChanged(match, index)) {\n      return true;\n    }\n\n    if (match.route.shouldReload) {\n      let prevUrl = createUrl(createHref(state.location));\n      return match.route.shouldReload({\n        prevUrl,\n        url,\n        submission,\n        params: match.params\n      });\n    }\n\n    return true;\n  };\n\n  let isInRootCatchBoundary = state.matches.length === 1;\n\n  if (isInRootCatchBoundary) {\n    return matches.filter(match => !!match.route.loader);\n  }\n\n  if ((fetcher === null || fetcher === void 0 ? void 0 : fetcher.type) === \"actionReload\") {\n    return matches.filter(filterByRouteProps);\n  } else if ( // mutation, reload for fresh data\n  state.transition.type === \"actionReload\" || state.transition.type === \"actionRedirect\" || // clicked the same link, resubmitted a GET form\n  createHref(url) === createHref(state.location) || // search affects all loaders\n  url.searchParams.toString() !== state.location.search.substring(1) || // a cookie was set\n  (_location$state = location.state) !== null && _location$state !== void 0 && _location$state.setCookie) {\n    return matches.filter(filterByRouteProps);\n  }\n\n  return matches.filter((match, index, arr) => {\n    var _location$state2;\n\n    // don't load errored action route\n    if ((actionErrorResult || actionCatchResult) && arr.length - 1 === index) {\n      return false;\n    }\n\n    return match.route.loader && (isNew(match, index) || matchPathChanged(match, index) || ((_location$state2 = location.state) === null || _location$state2 === void 0 ? void 0 : _location$state2.setCookie));\n  });\n}\n\nfunction isRedirectResult(result) {\n  return result.value instanceof TransitionRedirect;\n}\n\nfunction createHref(location) {\n  return location.pathname + location.search;\n}\n\nfunction findRedirect(results) {\n  for (let result of results) {\n    if (isRedirectResult(result)) {\n      return result.value;\n    }\n  }\n\n  return null;\n}\n\nasync function findCatchAndBoundaryId(results, matches, actionCatchResult) {\n  let loaderCatchResult;\n\n  for (let result of results) {\n    if (isCatchResult(result)) {\n      loaderCatchResult = result;\n      break;\n    }\n  }\n\n  let extractCatchData = async res => ({\n    status: res.status,\n    statusText: res.statusText,\n    data: res.data\n  }); // Weird case where action threw, and then a parent loader ALSO threw, we\n  // use the action catch but the loader's nearest boundary (cause we can't\n  // render down to the boundary the action would prefer)\n\n\n  if (actionCatchResult && loaderCatchResult) {\n    let boundaryId = findNearestCatchBoundary(loaderCatchResult.match, matches);\n    return [await extractCatchData(actionCatchResult.value), boundaryId];\n  }\n\n  if (loaderCatchResult) {\n    let boundaryId = findNearestCatchBoundary(loaderCatchResult.match, matches);\n    return [await extractCatchData(loaderCatchResult.value), boundaryId];\n  }\n\n  return null;\n}\n\nfunction findErrorAndBoundaryId(results, matches, actionErrorResult) {\n  let loaderErrorResult;\n\n  for (let result of results) {\n    if (isErrorResult(result)) {\n      loaderErrorResult = result;\n      break;\n    }\n  } // Weird case where action errored, and then a parent loader ALSO errored, we\n  // use the action error but the loader's nearest boundary (cause we can't\n  // render down to the boundary the action would prefer)\n\n\n  if (actionErrorResult && loaderErrorResult) {\n    let boundaryId = findNearestBoundary(loaderErrorResult.match, matches);\n    return [actionErrorResult.value, boundaryId];\n  }\n\n  if (actionErrorResult) {\n    let boundaryId = findNearestBoundary(actionErrorResult.match, matches);\n    return [actionErrorResult.value, boundaryId];\n  }\n\n  if (loaderErrorResult) {\n    let boundaryId = findNearestBoundary(loaderErrorResult.match, matches);\n    return [loaderErrorResult.value, boundaryId];\n  }\n\n  return [undefined, undefined];\n}\n\nfunction findNearestCatchBoundary(matchWithError, matches) {\n  let nearestBoundaryId = null;\n\n  for (let match of matches) {\n    if (match.route.CatchBoundary) {\n      nearestBoundaryId = match.route.id;\n    } // only search parents (stop at throwing match)\n\n\n    if (match === matchWithError) {\n      break;\n    }\n  }\n\n  return nearestBoundaryId;\n}\n\nfunction findNearestBoundary(matchWithError, matches) {\n  let nearestBoundaryId = null;\n\n  for (let match of matches) {\n    if (match.route.ErrorBoundary) {\n      nearestBoundaryId = match.route.id;\n    } // only search parents (stop at throwing match)\n\n\n    if (match === matchWithError) {\n      break;\n    }\n  }\n\n  return nearestBoundaryId;\n}\n\nfunction makeLoaderData(state, results, matches) {\n  let newData = {};\n\n  for (let {\n    match,\n    value\n  } of results) {\n    newData[match.route.id] = value;\n  }\n\n  let loaderData = {};\n\n  for (let {\n    route\n  } of matches) {\n    let value = newData[route.id] !== undefined ? newData[route.id] : state.loaderData[route.id];\n\n    if (value !== undefined) {\n      loaderData[route.id] = value;\n    }\n  }\n\n  return loaderData;\n}\n\nfunction isCatchResult(result) {\n  return result.value instanceof CatchValue;\n}\n\nfunction isErrorResult(result) {\n  return result.value instanceof Error;\n}\n\nfunction createUrl(href) {\n  return new URL(href, window.location.origin);\n} //#endregion\n\nexport { CatchValue, IDLE_FETCHER, IDLE_TRANSITION, TransitionRedirect, createTransitionManager };\n", "/**\n * @remix-run/react v1.3.3\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\nimport { matchRoutes } from 'react-router-dom';\n\n// TODO: We eventually might not want to import anything directly from `history`\nfunction matchClientRoutes(routes, location) {\n  let matches = matchRoutes(routes, location);\n  if (!matches) return null;\n  return matches.map(match => ({\n    params: match.params,\n    pathname: match.pathname,\n    route: match.route\n  }));\n}\n\nexport { matchClientRoutes };\n", "/**\n * @remix-run/react v1.3.3\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\nexport { RemixBrowser } from './browser.js';\nexport { Outlet, useHref, useLocation, useNavigate, useNavigationType, useOutlet, useOutletContext, useParams, useResolvedPath, useSearchParams } from 'react-router-dom';\nexport { Form, Link, Links, LiveReload, Meta, NavLink, PrefetchPageLinks, Scripts, useActionData, useBeforeUnload, useFetcher, useFetchers, useFormAction, useLoaderData, useMatches, useSubmit, useTransition } from './components.js';\nexport { useCatch } from './errorBoundaries.js';\nexport { ScrollRestoration } from './scroll-restoration.js';\nexport { RemixServer } from './server.js';\n", "/**\n * @remix-run/react v1.3.3\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\nimport * as React from 'react';\nimport { useLocation } from 'react-router-dom';\nimport { useBeforeUnload, useTransition } from './components.js';\n\nlet STORAGE_KEY = \"positions\";\nlet positions = {};\n\nif (typeof document !== \"undefined\") {\n  let sessionPositions = sessionStorage.getItem(STORAGE_KEY);\n\n  if (sessionPositions) {\n    positions = JSON.parse(sessionPositions);\n  }\n}\n/**\n * This component will emulate the browser's scroll restoration on location\n * changes.\n *\n * @see https://remix.run/api/remix#scrollrestoration\n */\n\n\nfunction ScrollRestoration() {\n  useScrollRestoration(); // wait for the browser to restore it on its own\n\n  React.useEffect(() => {\n    window.history.scrollRestoration = \"manual\";\n  }, []); // let the browser restore on it's own for refresh\n\n  useBeforeUnload(React.useCallback(() => {\n    window.history.scrollRestoration = \"auto\";\n  }, []));\n\n  let restoreScroll = (STORAGE_KEY => {\n    if (!window.history.state || !window.history.state.key) {\n      let key = Math.random().toString(32).slice(2);\n      window.history.replaceState({\n        key\n      }, \"\");\n    }\n\n    try {\n      let positions = JSON.parse(sessionStorage.getItem(STORAGE_KEY) || \"{}\");\n      let storedY = positions[window.history.state.key];\n\n      if (typeof storedY === \"number\") {\n        window.scrollTo(0, storedY);\n      }\n    } catch (error) {\n      console.error(error);\n      sessionStorage.removeItem(STORAGE_KEY);\n    }\n  }).toString();\n\n  return /*#__PURE__*/React.createElement(\"script\", {\n    suppressHydrationWarning: true,\n    dangerouslySetInnerHTML: {\n      __html: `(${restoreScroll})(${JSON.stringify(STORAGE_KEY)})`\n    }\n  });\n}\nlet hydrated = false;\n\nfunction useScrollRestoration() {\n  let location = useLocation();\n  let transition = useTransition();\n  let wasSubmissionRef = React.useRef(false);\n  React.useEffect(() => {\n    if (transition.submission) {\n      wasSubmissionRef.current = true;\n    }\n  }, [transition]);\n  React.useEffect(() => {\n    if (transition.location) {\n      positions[location.key] = window.scrollY;\n    }\n  }, [transition, location]);\n  useBeforeUnload(React.useCallback(() => {\n    sessionStorage.setItem(STORAGE_KEY, JSON.stringify(positions));\n  }, []));\n\n  if (typeof document !== \"undefined\") {\n    // eslint-disable-next-line\n    React.useLayoutEffect(() => {\n      // don't do anything on hydration, the component already did this with an\n      // inline script.\n      if (!hydrated) {\n        hydrated = true;\n        return;\n      }\n\n      let y = positions[location.key]; // been here before, scroll to it\n\n      if (y != undefined) {\n        window.scrollTo(0, y);\n        return;\n      } // try to scroll to the hash\n\n\n      if (location.hash) {\n        let el = document.getElementById(location.hash.slice(1));\n\n        if (el) {\n          el.scrollIntoView();\n          return;\n        }\n      } // don't do anything on submissions\n\n\n      if (wasSubmissionRef.current === true) {\n        wasSubmissionRef.current = false;\n        return;\n      } // otherwise go to the top on new locations\n\n\n      window.scrollTo(0, 0);\n    }, [location]);\n  }\n\n  React.useEffect(() => {\n    if (transition.submission) {\n      wasSubmissionRef.current = true;\n    }\n  }, [transition]);\n}\n\nexport { ScrollRestoration };\n", "/**\n * @remix-run/cloudflare v1.3.3\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\nexport { createCloudflareKVSessionStorage, createCookie, createCookieSessionStorage, createMemorySessionStorage, createSessionStorage } from '@remix-run/cloudflare';\n\n/**\n * @remix-run/server-runtime v1.3.3\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\nexport { createSession, isCookie, isSession, json, redirect } from '@remix-run/server-runtime';\n\n/**\n * @remix-run/react v1.3.3\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\nexport { Form, Link, Links, LiveReload, Meta, NavLink, Outlet, PrefetchPageLinks, RemixBrowser, RemixServer, Scripts, ScrollRestoration, useActionData, useBeforeUnload, useCatch, useFetcher, useFetchers, useFormAction, useHref, useLoaderData, useLocation, useMatches, useNavigate, useNavigationType, useOutlet, useOutletContext, useParams, useResolvedPath, useSearchParams, useSubmit, useTransition } from '@remix-run/react';\n\n"],
  "mappings": "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",
  "names": []
}
